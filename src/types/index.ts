/* eslint-disable max-len */
import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'

export type Maybe<T> = T | null
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
const defaultOptions = {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** Represents an ISO 8601-encoded date */
  Date: any
  /** Represents an ISO 8601-encoded datetime */
  DateTime: any
  /** Represents untyped JSON */
  JSON: any
  /** A valid URL, transported as a string */
  URL: any
}

/** Represents an Account */
export type Account = {
  __typename?: 'Account'
  /** Balance */
  balance: LedgerBalance
  /** ID */
  id: Scalars['ID']
  /** Last 4 numbers */
  lastFourDigits?: Maybe<Scalars['String']>
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
  /** Name */
  name: Scalars['String']
  /** Plaid Item account belongs to */
  plaidItem?: Maybe<PlaidItem>
  /** API Account Data Source */
  source?: Maybe<AccountSources>
  /** API Account Data Sources */
  sources?: Maybe<Array<AccountSources>>
  /** State */
  state: LedgerState
  /**
   * Status
   * @deprecated Use `state` instead.
   */
  status: LedgerStatus
  /** A limited list of transactions. Use `transactionsConnection` for a full paginated list. */
  transactions: Array<Transaction>
  /** Cursor-based pagination transactions */
  transactionsConnection: TransactionConnection
  /** Account type */
  type: AccountType
}

/** Represents an Account */
export type AccountSourceArgs = {
  type: AccountSourceType
}

/** Represents an Account */
export type AccountSourcesArgs = {
  types?: Maybe<Array<AccountSourceType>>
}

/** Represents an Account */
export type AccountTransactionsArgs = {
  filter?: Maybe<TransactionFilter>
  limit?: Scalars['Int']
  search?: Maybe<SearchQuery>
  sort?: Maybe<TransactionSort>
}

/** Represents an Account */
export type AccountTransactionsConnectionArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  filter?: Maybe<TransactionFilter>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  search?: Maybe<SearchQuery>
  sort?: Maybe<TransactionSort>
}

/** Options for Filtering Accounts */
export type AccountFilter = {
  /** Account classification */
  type?: Maybe<Array<AccountType>>
}

/** Represents a data source for the Account */
export enum AccountSourceType {
  /** Plaid connection */
  Plaid = 'PLAID',
}

export type AccountSources = PlaidAccount

/** Represents the classification of an Account */
export enum AccountType {
  /** Checking and cash management accounts */
  Checking = 'CHECKING',
  /** Credit card accounts */
  Credit = 'CREDIT',
  /** Brokerage, retirement and other retirement accounts */
  Investment = 'INVESTMENT',
  /** Lines of credit, mortgage, student and installment loans */
  Loan = 'LOAN',
  /** All other accounts */
  Other = 'OTHER',
  /** Savings and money market accounts */
  Savings = 'SAVINGS',
}

/** Autogenerated input type of AccountUpdate */
export type AccountUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
}

/** Autogenerated return type of AccountUpdate */
export type AccountUpdatePayload = {
  __typename?: 'AccountUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated Account Information */
  record?: Maybe<Account>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Represents an Error */
export type Error = {
  __typename?: 'Error'
  /** Error Message */
  message?: Maybe<Scalars['String']>
  /** Object path for error */
  path?: Maybe<Array<Scalars['String']>>
}

/** Represents an image */
export type Image = {
  __typename?: 'Image'
  /** URL for the image */
  url?: Maybe<Scalars['URL']>
}

export type LedgerBalance = {
  __typename?: 'LedgerBalance'
  /** The amount of funds including pending transactions */
  available?: Maybe<Scalars['Float']>
  /** The amount of funds based on posted transactions */
  current?: Maybe<Scalars['Float']>
  /** Cache Key */
  id: Scalars['ID']
  /** The amount of funds that may be overdraft or spent on credit */
  limit?: Maybe<Scalars['Float']>
}

export enum LedgerState {
  /** Terminated */
  Closed = 'CLOSED',
  /** Open */
  Open = 'OPEN',
  /** Disabled */
  Paused = 'PAUSED',
}

export enum LedgerStatus {
  /** Active */
  Active = 'ACTIVE',
  /** Terminated */
  Closed = 'CLOSED',
  /** Duplicate or disabled */
  Hidden = 'HIDDEN',
  /** Automation disabled */
  Paused = 'PAUSED',
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type Mutation = {
  __typename?: 'Mutation'
  /** Update Account Information */
  accountUpdate?: Maybe<AccountUpdatePayload>
  /** Create a Plaid Item from a successful Link submission */
  plaidItemCreate?: Maybe<PlaidItemCreatePayload>
  /** Delete a Plaid Item */
  plaidItemDelete?: Maybe<PlaidItemDeletePayload>
  /** Import a Plaid Item with a valid access token */
  plaidItemImport?: Maybe<PlaidItemImportPayload>
  /** Create a Link Token to configure an instance of Link */
  plaidLinkTokenCreate?: Maybe<PlaidLinkTokenCreatePayload>
  /** Create a Link Token to configure an instance of Link in update mode */
  plaidLinkTokenCreateForUpdate?: Maybe<PlaidLinkTokenCreateForUpdatePayload>
  /** Create a Plaid Processor Token suitable for sending to one of Plaid's integration partners */
  plaidProcessorTokenCreate?: Maybe<PlaidProcessorTokenCreatePayload>
  /** Update Profile Information */
  profileUpdate?: Maybe<ProfileUpdatePayload>
  /** Register a recurring event like a bill payment, paycheck or transfer */
  recurrenceCreate?: Maybe<RecurrenceCreatePayload>
  /** Update an existing recurring event like a bill payment, paycheck or transfer */
  recurrenceUpdate?: Maybe<RecurrenceUpdatePayload>
  /** Create a RoundUp */
  roundUpCreate?: Maybe<RoundUpCreatePayload>
  /** Pause a RoundUp */
  roundUpPause?: Maybe<RoundUpPausePayload>
  /** Resume a RoundUp */
  roundUpResume?: Maybe<RoundUpResumePayload>
  /** Set the funding account for a RoundUp */
  roundUpSetFundingAccount?: Maybe<RoundUpSetFundingAccountPayload>
  /** Set the RoundUp start time */
  roundUpSetStartTime?: Maybe<RoundUpSetStartTimePayload>
  /** Add Accounts to a RoundUp */
  roundUpSubscribedAccountsAdd?: Maybe<RoundUpSubscribedAccountsAddPayload>
  /** Remove Accounts from a RoundUp */
  roundUpSubscribedAccountsRemove?: Maybe<RoundUpSubscribedAccountsRemovePayload>
  /** Update Transaction Information */
  transactionUpdate?: Maybe<TransactionUpdatePayload>
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationAccountUpdateArgs = {
  input: AccountUpdateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidItemCreateArgs = {
  input: PlaidItemCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidItemDeleteArgs = {
  input: PlaidItemDeleteInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidItemImportArgs = {
  input: PlaidItemImportInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidLinkTokenCreateArgs = {
  input: PlaidLinkTokenCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidLinkTokenCreateForUpdateArgs = {
  input: PlaidLinkTokenCreateForUpdateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidProcessorTokenCreateArgs = {
  input: PlaidProcessorTokenCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationProfileUpdateArgs = {
  input: ProfileUpdateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRecurrenceCreateArgs = {
  input: RecurrenceCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRecurrenceUpdateArgs = {
  input: RecurrenceUpdateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpCreateArgs = {
  input: RoundUpCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpPauseArgs = {
  input: RoundUpPauseInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpResumeArgs = {
  input: RoundUpResumeInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpSetFundingAccountArgs = {
  input: RoundUpSetFundingAccountInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpSetStartTimeArgs = {
  input: RoundUpSetStartTimeInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpSubscribedAccountsAddArgs = {
  input: RoundUpSubscribedAccountsAddInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpSubscribedAccountsRemoveArgs = {
  input: RoundUpSubscribedAccountsRemoveInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationTransactionUpdateArgs = {
  input: TransactionUpdateInput
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo'
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>
}

/** Represents a Plaid API Error */
export type PlaidApiError = {
  __typename?: 'PlaidAPIError'
  /** The particular error code */
  code: Scalars['String']
  /** A user-friendly representation of the error code */
  displayMessage?: Maybe<Scalars['String']>
  /** A developer-friendly representation of the error code */
  message: Scalars['String']
  /** A unique identifying the request, to be used for troubleshooting purposes */
  requestId?: Maybe<Scalars['String']>
  /** A broad categorization of the error */
  type: Scalars['String']
}

/** Plaid Account Data */
export type PlaidAccount = {
  __typename?: 'PlaidAccount'
  /** API Source */
  _sourcename: AccountSourceType
  /** Plaid’s unique identifier for the account */
  accountId: Scalars['String']
  /** A set of fields describing the balance for an account. */
  balances: PlaidAccountBalances
  /**
   * The last 2-4 alphanumeric characters of an account's official account number.
   * Note that the mask may be non-unique between an Item's accounts, and it may
   * also not match the mask that the bank displays to the user.
   */
  mask?: Maybe<Scalars['String']>
  /** The name of the account, either assigned by the user or by the financial institution itself */
  name: Scalars['String']
  /** The official name of the account as given by the financial institution */
  officialName?: Maybe<Scalars['String']>
  /**
   * Possible values: 401a, 401k, 403B, 457b, 529, brokerage, cash isa, education
   * savings account, gic, health reimbursement arrangement, hsa, isa, ira, lif,
   * lira, lrif, lrsp, non-taxable brokerage account, other, prif, rdsp, resp,
   * rlif, rrif, pension, profit sharing plan, retirement, roth, roth 401k, rrsp,
   * sep ira, simple ira, sipp, stock plan, thrift savings plan, tfsa, trust, ugma,
   * utma, variable annuity, credit card, paypal, cd, checking, savings, money
   * market, prepaid, auto, commercial, construction, consumer, home, home equity,
   * loan, mortgage, overdraft, line of credit, student, cash management, keogh,
   * mutual fund, recurring, rewards, safe deposit, sarsep, null
   */
  subtype?: Maybe<Scalars['String']>
  /** Possible values: investment, credit, depository, loan, brokerage, other */
  type: Scalars['String']
  /**
   * The current verification status of an Auth Item initiated through Automated or
   * Manual micro-deposits.  Returned for Auth Items only.
   * Possible values: pending_automatic_verification, pending_manual_verification,
   * manually_verified, verification_expired, verification_failed
   */
  verificationStatus?: Maybe<Scalars['String']>
}

/** Plaid Account Balances Data */
export type PlaidAccountBalances = {
  __typename?: 'PlaidAccountBalances'
  /** The amount of funds available to be withdrawn from the account, as determined by the financial institution. */
  available?: Maybe<Scalars['Float']>
  /** The total amount of funds in or owed by the account. */
  current: Scalars['Float']
  /** The ISO-4217 currency code of the balance. Always null if unofficial_currency_code is non-null. */
  isoCurrencyCode?: Maybe<Scalars['String']>
  /** For credit-type accounts, this represents the credit limit. */
  limit?: Maybe<Scalars['Float']>
  /**
   * The unofficial currency code associated with the balance. Always null if
   * iso_currency_code is non-null. Unofficial currency codes are used for
   * currencies that do not have official ISO currency codes, such as
   * cryptocurrencies and the currencies of certain countries.
   */
  unofficialCurrencyCode?: Maybe<Scalars['String']>
}

/** Represents a Plaid item */
export type PlaidItem = {
  __typename?: 'PlaidItem'
  /** Accounts */
  accounts: Array<Account>
  /** Number of accounts */
  accountsCount: Scalars['Int']
  /** Is this Plaid Item managed by an external system? */
  externallyManaged: Scalars['Boolean']
  /** Plaid Item ID */
  id: Scalars['ID']
  /** Institution logo */
  logo?: Maybe<Image>
  /** Name of the Plaid Item */
  name: Scalars['String']
  /** Item status */
  status: PlaidItemStatus
  /** Last sync time */
  syncedAt?: Maybe<Scalars['DateTime']>
}

/** Autogenerated input type of PlaidItemCreate */
export type PlaidItemCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `metadata` object from Plaid Link's `onSuccess` callback */
  metadata: Scalars['JSON']
  /** The `public_token` string from Plaid Link's `onSuccess` callback */
  publicToken: Scalars['String']
}

/** Autogenerated return type of PlaidItemCreate */
export type PlaidItemCreatePayload = {
  __typename?: 'PlaidItemCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Plaid Item */
  record?: Maybe<PlaidItem>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of PlaidItemDelete */
export type PlaidItemDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of Plaid Item to delete */
  id: Scalars['ID']
}

/** Autogenerated return type of PlaidItemDelete */
export type PlaidItemDeletePayload = {
  __typename?: 'PlaidItemDeletePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Plaid Item */
  record?: Maybe<PlaidItem>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of PlaidItemImport */
export type PlaidItemImportInput = {
  /** The `access_token` for the item */
  accessToken: Scalars['String']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Is this Plaid Item managed by an external system? */
  externallyManaged?: Maybe<Scalars['Boolean']>
}

/** Autogenerated return type of PlaidItemImport */
export type PlaidItemImportPayload = {
  __typename?: 'PlaidItemImportPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Plaid Item */
  record?: Maybe<PlaidItem>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Represents the sync status of a Plaid Item */
export enum PlaidItemStatus {
  /** Needs reconnecting */
  Disconnected = 'DISCONNECTED',
  /** In an error state */
  Error = 'ERROR',
  /** Successfully synced */
  Synced = 'SYNCED',
  /** Currently syncing */
  Syncing = 'SYNCING',
}

/** Autogenerated return type of PlaidItemUpdated */
export type PlaidItemUpdatedPayload = {
  __typename?: 'PlaidItemUpdatedPayload'
  record?: Maybe<PlaidItem>
}

export type PlaidLinkAccountFiltersCreditAccountSubtypesInput = {
  accountSubtypes: Array<Scalars['String']>
}

export type PlaidLinkAccountFiltersDepositoryAccountSubtypesInput = {
  accountSubtypes: Array<Scalars['String']>
}

export type PlaidLinkAccountFiltersInput = {
  credit?: Maybe<PlaidLinkAccountFiltersCreditAccountSubtypesInput>
  depository?: Maybe<PlaidLinkAccountFiltersDepositoryAccountSubtypesInput>
}

/** Represents a Link Token */
export type PlaidLinkToken = {
  __typename?: 'PlaidLinkToken'
  /** Expiration time of the `link_token` */
  expiration: Scalars['DateTime']
  /** A `link_token` that can be supplied to initialize Plaid Link */
  linkToken: Scalars['ID']
}

/** Autogenerated input type of PlaidLinkTokenCreateForUpdate */
export type PlaidLinkTokenCreateForUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** An array of Plaid-supported country codes using ISO-3166-1 alpha-2 country code standard */
  countryCodes?: Maybe<Array<Scalars['String']>>
  /** The language that Link should be displayed in. Defaults to your Quiltt app's language */
  language?: Maybe<Scalars['String']>
  /** The name of the Link customization from the Plaid Dashboard to be applied to Link */
  linkCustomizationName?: Maybe<Scalars['String']>
  /** The ID of the Plaid Item to update */
  plaidItemId: Scalars['ID']
}

/** Autogenerated return type of PlaidLinkTokenCreateForUpdate */
export type PlaidLinkTokenCreateForUpdatePayload = {
  __typename?: 'PlaidLinkTokenCreateForUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Link Token */
  record?: Maybe<PlaidLinkToken>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of PlaidLinkTokenCreate */
export type PlaidLinkTokenCreateInput = {
  accountFilters?: Maybe<PlaidLinkAccountFiltersInput>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** An array of Plaid-supported country codes using ISO-3166-1 alpha-2 country code standard */
  countryCodes?: Maybe<Array<Scalars['String']>>
  /** The language that Link should be displayed in. Defaults to your Quiltt app's language */
  language?: Maybe<Scalars['String']>
  /** The name of the Link customization from the Plaid Dashboard to be applied to Link */
  linkCustomizationName?: Maybe<Scalars['String']>
  /** List of products to use with Link */
  products: Array<Scalars['String']>
}

/** Autogenerated return type of PlaidLinkTokenCreate */
export type PlaidLinkTokenCreatePayload = {
  __typename?: 'PlaidLinkTokenCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Link Token */
  record?: Maybe<PlaidLinkToken>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Represents a Processor Token */
export type PlaidProcessorToken = {
  __typename?: 'PlaidProcessorToken'
  /** The `processor_token` that can then be used by the Plaid partner to make API requests */
  processorToken: Scalars['ID']
}

/** Autogenerated input type of PlaidProcessorTokenCreate */
export type PlaidProcessorTokenCreateInput = {
  /**
   * The Plaid `account_id` from Plaid Link's `onSuccess` callback or the
   * `accountId` from the Quiltt Account's PlaidAccount source
   */
  accountId: Scalars['ID']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** The ID of the Plaid Item data is being requested for */
  plaidItemId: Scalars['ID']
  /** The processor you are integrating with */
  processor: Scalars['String']
}

/** Autogenerated return type of PlaidProcessorTokenCreate */
export type PlaidProcessorTokenCreatePayload = {
  __typename?: 'PlaidProcessorTokenCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Processor token */
  record?: Maybe<PlaidProcessorToken>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Plaid Transaction Data */
export type PlaidTransaction = {
  __typename?: 'PlaidTransaction'
  /** API Source */
  _sourcename: TransactionSourceType
  /** The ID of the account in which this transaction occurred. */
  accountId: Scalars['String']
  /** The name of the account owner. This field is not typically populated and only relevant when dealing with sub-accounts. */
  accountOwner?: Maybe<Scalars['String']>
  /**
   * The settled value of the transaction, denominated in the account's currency,
   * as stated in iso_currency_code or unofficial_currency_code. Positive values
   * when money moves out of the account; negative values when money moves in. For
   * example, debit card purchases are positive; credit card payments, direct
   * deposits, and refunds are negative.
   */
  amount: Scalars['Float']
  /** The date that the transaction was authorized. Dates are returned in an ISO 8601 format ( YYYY-MM-DD ). */
  authorizedDate?: Maybe<Scalars['String']>
  /** Date and time when a transaction was authorized in ISO 8601 format ( YYYY-MM-DDTHH:mm:ssZ ). */
  authorizedDatetime?: Maybe<Scalars['String']>
  /** A hierarchical array of the categories to which this transaction belongs. */
  category?: Maybe<Array<Scalars['String']>>
  /** The ID of the category to which this transaction belongs. */
  categoryId: Scalars['String']
  /**
   * For pending transactions, the date that the transaction occurred; for posted
   * transactions, the date that the transaction posted. Both dates are returned in
   * an ISO 8601 format ( YYYY-MM-DD ).
   */
  date: Scalars['Date']
  /** Date and time when a transaction was posted in ISO 8601 format ( YYYY-MM-DDTHH:mm:ssZ ). */
  datetime?: Maybe<Scalars['DateTime']>
  /** The ISO-4217 currency code of the transaction. Always null if unofficial_currency_code is non-null. */
  isoCurrencyCode?: Maybe<Scalars['String']>
  /** A representation of where a transaction took place */
  location: PlaidTransactionLocation
  /** The merchant name, as extracted by Plaid from the name field. */
  merchantName?: Maybe<Scalars['String']>
  /** The merchant name or transaction description. */
  name: Scalars['String']
  /** The channel used to make a payment. Possible values: online, in store, other */
  paymentChannel: Scalars['String']
  /**
   * Transaction information specific to inter-bank transfers. If the transaction
   * was not an inter-bank transfer, all fields will be null.
   */
  paymentMeta: PlaidTransactionPaymentMeta
  /**
   * When true, identifies the transaction as pending or unsettled. Pending
   * transaction details (name, type, amount, category ID) may change before they are settled.
   */
  pending: Scalars['Boolean']
  /** The ID of a posted transaction's associated pending transaction, where applicable. */
  pendingTransactionId?: Maybe<Scalars['String']>
  /**
   * An identifier classifying the transaction type. Possible values: adjustment,
   * atm, bank charge, bill payment, cash, cashback, cheque, direct debit,
   * interest, purchase, standing order, transfer, null
   */
  transactionCode?: Maybe<Scalars['String']>
  /** The unique ID of the transaction. */
  transactionId: Scalars['String']
  /**
   * The unofficial currency code associated with the transaction. Always null if
   * iso_currency_code is non-null. Unofficial currency codes are used for
   * currencies that do not have official ISO currency codes, such as
   * cryptocurrencies and the currencies of certain countries.
   */
  unofficialCurrencyCode?: Maybe<Scalars['String']>
}

/** Plaid Transaction Data */
export type PlaidTransactionLocation = {
  __typename?: 'PlaidTransactionLocation'
  /** The street address where the transaction occurred. */
  address?: Maybe<Scalars['String']>
  /** The city where the transaction occurred. */
  city?: Maybe<Scalars['String']>
  /** The ISO 3166-1 alpha-2 country code where the transaction occurred. */
  country?: Maybe<Scalars['String']>
  /** The latitude where the transaction occurred. */
  lat?: Maybe<Scalars['Float']>
  /** The longitude where the transaction occurred. */
  lon?: Maybe<Scalars['Float']>
  /** The postal code where the transaction occurred. */
  postalCode?: Maybe<Scalars['String']>
  /** The region or state where the transaction occurred. */
  region?: Maybe<Scalars['String']>
  /** The merchant defined store number where the transaction occurred. */
  storeNumber?: Maybe<Scalars['String']>
}

/** Plaid Transaction PaymentMeta Data */
export type PlaidTransactionPaymentMeta = {
  __typename?: 'PlaidTransactionPaymentMeta'
  /** The party initiating a wire transfer. Will be null if the transaction is not a wire transfer. */
  byOrderOf?: Maybe<Scalars['String']>
  /** For transfers, the party that is receiving the transaction. */
  payee?: Maybe<Scalars['String']>
  /** For transfers, the party that is paying the transaction. */
  payer?: Maybe<Scalars['String']>
  /** The type of transfer, e.g. 'ACH' */
  paymentMethod?: Maybe<Scalars['String']>
  /** The name of the payment processor */
  paymentProcessor?: Maybe<Scalars['String']>
  /** The ACH PPD ID for the payer. */
  ppdId?: Maybe<Scalars['String']>
  /** The payer-supplied description of the transfer. */
  reason?: Maybe<Scalars['String']>
  /** The transaction reference number supplied by the financial institution. */
  referenceNumber?: Maybe<Scalars['String']>
}

/** Represents a Profile */
export type Profile = {
  __typename?: 'Profile'
  /** Email */
  email?: Maybe<Scalars['String']>
  /** ID */
  id: Scalars['ID']
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
  /** Name */
  name?: Maybe<Scalars['String']>
  /** Cellphone */
  phone?: Maybe<Scalars['String']>
}

/** Autogenerated input type of ProfileUpdate */
export type ProfileUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Email */
  email?: Maybe<Scalars['String']>
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
  /** Name */
  name?: Maybe<Scalars['String']>
  /** Cellphone in E164 Format */
  phone?: Maybe<Scalars['String']>
}

/** Autogenerated return type of ProfileUpdate */
export type ProfileUpdatePayload = {
  __typename?: 'ProfileUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated Profile Information */
  record?: Maybe<Profile>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** The top-level Query type. Queries are used to fetch data. */
export type Query = {
  __typename?: 'Query'
  /** Look up an Account by its ID */
  account?: Maybe<Account>
  /** Get a list of a person's Accounts */
  accounts?: Maybe<Array<Account>>
  /** Look up a Plaid Item by its ID */
  plaidItem?: Maybe<PlaidItem>
  /** Get a list of the user's Plaid Items */
  plaidItems?: Maybe<Array<PlaidItem>>
  /** Get profile information for the authenticated user */
  profile?: Maybe<Profile>
  /** Look up a Recurrence by its ID */
  recurrence?: Maybe<Recurrence>
  /** Get a list of the user's Recurrences, sorted by next payment date */
  recurrences?: Maybe<Array<Recurrence>>
  /** Look up a RoundUp by its ID */
  roundUp?: Maybe<RoundUp>
  /** Get a list of the user's RoundUps */
  roundUps?: Maybe<Array<RoundUp>>
  /** Look up a Transaction by its ID */
  transaction?: Maybe<Transaction>
  /** Get a cursor paginated list of the person's Transactions */
  transactionsConnection: TransactionConnection
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryAccountArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryAccountsArgs = {
  filter?: Maybe<AccountFilter>
  search?: Maybe<SearchQuery>
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryPlaidItemArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryRecurrenceArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryRoundUpArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryTransactionArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryTransactionsConnectionArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  filter?: Maybe<TransactionFilter>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  search?: Maybe<SearchQuery>
  sort?: Maybe<TransactionSort>
}

/** Represents a recurring set of transactions */
export type Recurrence = {
  __typename?: 'Recurrence'
  entryType: RecurrenceEntryType
  frequency: RecurrenceFrequency
  /** ID */
  id: Scalars['ID']
  /** Name */
  name?: Maybe<Scalars['String']>
  /** State */
  state: LedgerState
  /**
   * Status
   * @deprecated Use `state` instead.
   */
  status: LedgerStatus
  /** The next projected payment */
  transactionNext?: Maybe<Transaction>
  /** A limited list of transactions. Use `transactionsConnection` for a full paginated list. */
  transactions: Array<Transaction>
  /** Cursor-based pagination transactions */
  transactionsConnection: TransactionConnection
}

/** Represents a recurring set of transactions */
export type RecurrenceTransactionsArgs = {
  filter?: Maybe<TransactionFilter>
  limit?: Scalars['Int']
  search?: Maybe<SearchQuery>
  sort?: Maybe<TransactionSort>
}

/** Represents a recurring set of transactions */
export type RecurrenceTransactionsConnectionArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  filter?: Maybe<TransactionFilter>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  search?: Maybe<SearchQuery>
  sort?: Maybe<TransactionSort>
}

/** Autogenerated input type of RecurrenceCreate */
export type RecurrenceCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  frequency: RecurrenceFrequency
  transactionId: Scalars['ID']
}

/** Autogenerated return type of RecurrenceCreate */
export type RecurrenceCreatePayload = {
  __typename?: 'RecurrenceCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated bill */
  record?: Maybe<Recurrence>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Whether the Recurrence represent money being advanced into or withdrawn from the account. */
export enum RecurrenceEntryType {
  /** a set of entries recording money being advanced into the account */
  Inflow = 'INFLOW',
  /** a set of entries recording money being withdrawn from the account */
  Outflow = 'OUTFLOW',
}

/** Represents the frequency of a recurring event */
export enum RecurrenceFrequency {
  /** Every year */
  Annually = 'ANNUALLY',
  /** Every daily */
  Daily = 'DAILY',
  /** Every two weeks */
  Fortnightly = 'FORTNIGHTLY',
  /** Every month */
  Monthly = 'MONTHLY',
  /** Every three months */
  Quarterly = 'QUARTERLY',
  /** Every six months */
  Semiannually = 'SEMIANNUALLY',
  /** Twice per month, 1st & 15th */
  SemimonthlyEarly = 'SEMIMONTHLY_EARLY',
  /** Twice per month, 15th & End of Month */
  SemimonthlyLate = 'SEMIMONTHLY_LATE',
  /** Every thirty days */
  ThirtyDays = 'THIRTY_DAYS',
  /** Every week */
  Weekly = 'WEEKLY',
}

/** Autogenerated input type of RecurrenceUpdate */
export type RecurrenceUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  frequency: RecurrenceFrequency
}

/** Autogenerated return type of RecurrenceUpdate */
export type RecurrenceUpdatePayload = {
  __typename?: 'RecurrenceUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated bill */
  record?: Maybe<Recurrence>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Represents a RoundUp */
export type RoundUp = {
  __typename?: 'RoundUp'
  /** Eligible accounts available for this RoundUp */
  availableAccounts: Array<Account>
  /** Balance */
  balance: LedgerBalance
  /** Source or Funding account for this RoundUp */
  fundingAccount?: Maybe<Account>
  /** ID */
  id: Scalars['ID']
  /** State */
  state: LedgerState
  /**
   * Status
   * @deprecated Use `state` instead.
   */
  status: LedgerStatus
  /** Accounts subscribed to this RoundUp */
  subscribedAccounts: Array<Account>
  /** A limited list of transactions. Use `transactionsConnection` for a full paginated list. */
  transactions: Array<Transaction>
  /** Cursor-based pagination transactions */
  transactionsConnection: TransactionConnection
}

/** Represents a RoundUp */
export type RoundUpBalanceArgs = {
  filter?: Maybe<TransactionFilter>
}

/** Represents a RoundUp */
export type RoundUpTransactionsArgs = {
  filter?: Maybe<TransactionFilter>
  limit?: Scalars['Int']
  search?: Maybe<SearchQuery>
  sort?: Maybe<TransactionSort>
}

/** Represents a RoundUp */
export type RoundUpTransactionsConnectionArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  filter?: Maybe<TransactionFilter>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  search?: Maybe<SearchQuery>
  sort?: Maybe<TransactionSort>
}

/** Autogenerated input type of RoundUpCreate */
export type RoundUpCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the funding account */
  fundingAccountId?: Maybe<Scalars['ID']>
  /** IDs of subscribed accounts */
  subscribedAccountIds?: Maybe<Array<Scalars['ID']>>
}

/** Autogenerated return type of RoundUpCreate */
export type RoundUpCreatePayload = {
  __typename?: 'RoundUpCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Created RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpPause */
export type RoundUpPauseInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpPause */
export type RoundUpPausePayload = {
  __typename?: 'RoundUpPausePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Paused RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpResume */
export type RoundUpResumeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpResume */
export type RoundUpResumePayload = {
  __typename?: 'RoundUpResumePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Resumed RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpSetFundingAccount */
export type RoundUpSetFundingAccountInput = {
  /** ID of the new funding account to use */
  accountId: Scalars['ID']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpSetFundingAccount */
export type RoundUpSetFundingAccountPayload = {
  __typename?: 'RoundUpSetFundingAccountPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpSetStartTime */
export type RoundUpSetStartTimeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
  /** Time to start rounding up at */
  startAt: Scalars['DateTime']
}

/** Autogenerated return type of RoundUpSetStartTime */
export type RoundUpSetStartTimePayload = {
  __typename?: 'RoundUpSetStartTimePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpSubscribedAccountsAdd */
export type RoundUpSubscribedAccountsAddInput = {
  /** IDs of added Accounts */
  accountIds: Array<Scalars['ID']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpSubscribedAccountsAdd */
export type RoundUpSubscribedAccountsAddPayload = {
  __typename?: 'RoundUpSubscribedAccountsAddPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpSubscribedAccountsRemove */
export type RoundUpSubscribedAccountsRemoveInput = {
  /** IDs of removed Accounts */
  accountIds: Array<Scalars['ID']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpSubscribedAccountsRemove */
export type RoundUpSubscribedAccountsRemovePayload = {
  __typename?: 'RoundUpSubscribedAccountsRemovePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Options for Searching */
export type SearchQuery = {
  /** Query for searching */
  term?: Maybe<Scalars['String']>
}

/** Spade Location Data */
export type SpadeLocation = {
  __typename?: 'SpadeLocation'
  /** Street and number */
  address?: Maybe<Scalars['String']>
  /** City or town */
  city?: Maybe<Scalars['String']>
  /** Latitude coordinate */
  latitude?: Maybe<Scalars['String']>
  /** Longitude coordinate */
  longitude?: Maybe<Scalars['String']>
  /** State, Province, Territory etc. */
  state?: Maybe<Scalars['String']>
  /** Store number of chain retailer */
  storeNumber?: Maybe<Scalars['String']>
  /** Zip or postal code */
  zipCode?: Maybe<Scalars['String']>
}

/** Spade Logo Data */
export type SpadeLogo = {
  __typename?: 'SpadeLogo'
  /** Name of the logo (for use in logo endpoint, same as path) */
  logoName: Scalars['String']
  /** Path to the image */
  path: Scalars['String']
  /** mime type of image (currently all are PNGs) */
  type: Scalars['String']
  /** Is this logo from our verified logo database */
  verified: Scalars['Boolean']
}

/** Spade Merchant Info Data */
export type SpadeMerchantInfo = {
  __typename?: 'SpadeMerchantInfo'
  hasPhysicalLocations?: Maybe<Scalars['String']>
  name?: Maybe<Scalars['String']>
  verified?: Maybe<Scalars['Boolean']>
  website?: Maybe<Scalars['String']>
}

/** Spade Transaction Data */
export type SpadeTransaction = {
  __typename?: 'SpadeTransaction'
  /** API Source */
  _sourcename: TransactionSourceType
  /**
   * List of increasingly specific categories based off the given MCC or our
   * merchant database. We reccomend using the second element as a reasonably
   * specific starting point.
   */
  category?: Maybe<Array<Scalars['String']>>
  /** Is likely a recurring transaction */
  isRecurring?: Maybe<Scalars['String']>
  location?: Maybe<SpadeLocation>
  logo?: Maybe<SpadeLogo>
  /** 'Merchant Category Code' (Marqueta, Galileo, etc.) */
  mcc?: Maybe<Scalars['String']>
  merchantInfo?: Maybe<SpadeMerchantInfo>
  /** Name of the merchant */
  merchantName?: Maybe<Scalars['String']>
  /** Our best guess as to what the true merchant name is. Utilizing AI, our database of merchants, and geolocation providers. */
  normalizedMerchantName?: Maybe<Scalars['String']>
  /** 'category_id' from Plaid */
  plaidCategoryId?: Maybe<Scalars['String']>
  /** Description of the transaction (often just called 'name') */
  transactionName?: Maybe<Scalars['String']>
  /** Facilitator of transaction */
  via?: Maybe<Scalars['String']>
}

/** The top-level Subscription type. Subscriptions are used to watch for events emitted from the server. */
export type Subscription = {
  __typename?: 'Subscription'
  /** A plaid item was updated */
  plaidItemUpdated: PlaidItemUpdatedPayload
}

/** The top-level Subscription type. Subscriptions are used to watch for events emitted from the server. */
export type SubscriptionPlaidItemUpdatedArgs = {
  id: Scalars['ID']
}

/** Represents a Transaction */
export type Transaction = {
  __typename?: 'Transaction'
  /** Transaction account */
  account: Account
  /** Amount */
  amount: Scalars['Float']
  /** Date of Record */
  date: Scalars['Date']
  /** Description or Line Item Name */
  description: Scalars['String']
  /** CREDIT or DEBIT */
  entryType: TransactionEntryType
  /** ID */
  id: Scalars['ID']
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
  /** API Transaction Data Source */
  source?: Maybe<TransactionSources>
  /** API Transaction Data Sources */
  sources?: Maybe<Array<TransactionSources>>
  /** Status */
  status: TransactionStatus
}

/** Represents a Transaction */
export type TransactionSourceArgs = {
  type: TransactionSourceType
}

/** Represents a Transaction */
export type TransactionSourcesArgs = {
  types?: Maybe<Array<TransactionSourceType>>
}

/** The connection type for Transaction. */
export type TransactionConnection = {
  __typename?: 'TransactionConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TransactionEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Transaction>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
}

/** An edge in a connection. */
export type TransactionEdge = {
  __typename?: 'TransactionEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<Transaction>
}

/** Whether the Transaction is a CREDIT or DEBIT */
export enum TransactionEntryType {
  /** an entry recording money being advanced into the account */
  Credit = 'CREDIT',
  /** an entry recording money being withdrawn from the account */
  Debit = 'DEBIT',
}

/** Options for Filtering Transactions */
export type TransactionFilter = {
  /** Account IDs */
  accountIds?: Maybe<Array<Scalars['ID']>>
  /** Amount */
  amount?: Maybe<Scalars['Float']>
  /** Amount */
  amount_abs?: Maybe<Scalars['Float']>
  /** Greater than the absolute value of Amount */
  amount_abs_gt?: Maybe<Scalars['Float']>
  /** Greater than or equal to the absolute value of Amount */
  amount_abs_gte?: Maybe<Scalars['Float']>
  /** Less than the absolute value of Amount */
  amount_abs_lt?: Maybe<Scalars['Float']>
  /** Less than or equal to the absolute value of Amount */
  amount_abs_lte?: Maybe<Scalars['Float']>
  /** Greater than the Amount */
  amount_gt?: Maybe<Scalars['Float']>
  /** Greater than or equal to the Amount */
  amount_gte?: Maybe<Scalars['Float']>
  /** Less than the Amount */
  amount_lt?: Maybe<Scalars['Float']>
  /** Less than or equal to the Amount */
  amount_lte?: Maybe<Scalars['Float']>
  /** Date */
  date?: Maybe<Scalars['Date']>
  /** Greater than the Date */
  date_gt?: Maybe<Scalars['Date']>
  /** Greater than or equal to the Date */
  date_gte?: Maybe<Scalars['Date']>
  /** Less than the Date */
  date_lt?: Maybe<Scalars['Date']>
  /** Less than or equal to the Date */
  date_lte?: Maybe<Scalars['Date']>
  entryType?: Maybe<TransactionEntryType>
  source?: Maybe<TransactionFilterSourceInput>
  /** Transaction status */
  status?: Maybe<Array<TransactionStatus>>
}

/** Source-specific filters */
export type TransactionFilterSourceInput = {
  plaid?: Maybe<TransactionFilterSourcePlaidInput>
}

/** Options for filtering inside Plaid's API payloads */
export type TransactionFilterSourcePlaidInput = {
  /** The ID of the account in which this transaction occurred. */
  accountId?: Maybe<Scalars['String']>
  /** The name of the account owner. This field is not typically populated and only relevant when dealing with sub-accounts. */
  accountOwner?: Maybe<Scalars['String']>
  /**
   * The settled value of the transaction, denominated in the account's currency,
   * as stated in iso_currency_code or unofficial_currency_code. Positive values
   * when money moves out of the account; negative values when money moves in. For
   * example, debit card purchases are positive; credit card payments, direct
   * deposits, and refunds are negative.
   */
  amount?: Maybe<Scalars['Float']>
  /** The date that the transaction was authorized. Dates are returned in an ISO 8601 format ( YYYY-MM-DD ). */
  authorizedDate?: Maybe<Scalars['String']>
  /** Date and time when a transaction was authorized in ISO 8601 format ( YYYY-MM-DDTHH:mm:ssZ ). */
  authorizedDatetime?: Maybe<Scalars['String']>
  /** A hierarchical array of the categories to which this transaction belongs. */
  category?: Maybe<Array<Scalars['String']>>
  /** The ID of the category to which this transaction belongs. */
  categoryId?: Maybe<Scalars['String']>
  /**
   * For pending transactions, the date that the transaction occurred; for posted
   * transactions, the date that the transaction posted. Both dates are returned in
   * an ISO 8601 format ( YYYY-MM-DD ).
   */
  date?: Maybe<Scalars['Date']>
  /** Date and time when a transaction was posted in ISO 8601 format ( YYYY-MM-DDTHH:mm:ssZ ). */
  datetime?: Maybe<Scalars['DateTime']>
  /** The ISO-4217 currency code of the transaction. Always null if unofficial_currency_code is non-null. */
  isoCurrencyCode?: Maybe<Scalars['String']>
  location?: Maybe<TransactionFilterSourcePlaidLocationInput>
  /** The merchant name, as extracted by Plaid from the name field. */
  merchantName?: Maybe<Scalars['String']>
  /** The merchant name or transaction description. */
  name?: Maybe<Scalars['String']>
  /** The channel used to make a payment. Possible values: online, in store, other */
  paymentChannel?: Maybe<Scalars['String']>
  paymentMeta?: Maybe<TransactionFilterSourcePlaidPaymentMetaInput>
  /**
   * When true, identifies the transaction as pending or unsettled. Pending
   * transaction details (name, type, amount, category ID) may change before they are settled.
   */
  pending?: Maybe<Scalars['Boolean']>
  /** The ID of a posted transaction's associated pending transaction, where applicable. */
  pendingTransactionId?: Maybe<Scalars['String']>
  /**
   * An identifier classifying the transaction type. Possible values: adjustment,
   * atm, bank charge, bill payment, cash, cashback, cheque, direct debit,
   * interest, purchase, standing order, transfer, null
   */
  transactionCode?: Maybe<Scalars['String']>
  /** The unique ID of the transaction. */
  transactionId?: Maybe<Scalars['String']>
  /**
   * The unofficial currency code associated with the transaction. Always null if
   * iso_currency_code is non-null. Unofficial currency codes are used for
   * currencies that do not have official ISO currency codes, such as
   * cryptocurrencies and the currencies of certain countries.
   */
  unofficialCurrencyCode?: Maybe<Scalars['String']>
}

/** Options for filtering inside Plaid's Transaction Location data */
export type TransactionFilterSourcePlaidLocationInput = {
  /** The street address where the transaction occurred. */
  address?: Maybe<Scalars['String']>
  /** The city where the transaction occurred. */
  city?: Maybe<Scalars['String']>
  /** The ISO 3166-1 alpha-2 country code where the transaction occurred. */
  country?: Maybe<Scalars['String']>
  /** The latitude where the transaction occurred. */
  lat?: Maybe<Scalars['Float']>
  /** The longitude where the transaction occurred. */
  lon?: Maybe<Scalars['Float']>
  /** The postal code where the transaction occurred. */
  postalCode?: Maybe<Scalars['String']>
  /** The region or state where the transaction occurred. */
  region?: Maybe<Scalars['String']>
  /** The merchant defined store number where the transaction occurred. */
  storeNumber?: Maybe<Scalars['String']>
}

/** Options for filtering inside Plaid's Transaction Payment Meta data */
export type TransactionFilterSourcePlaidPaymentMetaInput = {
  /** The party initiating a wire transfer. Will be null if the transaction is not a wire transfer. */
  byOrderOf?: Maybe<Scalars['String']>
  /** For transfers, the party that is receiving the transaction. */
  payee?: Maybe<Scalars['String']>
  /** For transfers, the party that is paying the transaction. */
  payer?: Maybe<Scalars['String']>
  /** The type of transfer, e.g. 'ACH' */
  paymentMethod?: Maybe<Scalars['String']>
  /** The name of the payment processor */
  paymentProcessor?: Maybe<Scalars['String']>
  /** The ACH PPD ID for the payer. */
  ppdId?: Maybe<Scalars['String']>
  /** The payer-supplied description of the transfer. */
  reason?: Maybe<Scalars['String']>
  /** The transaction reference number supplied by the financial institution. */
  referenceNumber?: Maybe<Scalars['String']>
}

/** Options for Sorting Transactions */
export enum TransactionSort {
  /** Oldest First, Pending Last */
  DateAsc = 'DATE_ASC',
  /** Newest First, Pending First */
  DateDesc = 'DATE_DESC',
}

/** Represents a data source for the Transaction */
export enum TransactionSourceType {
  /** Plaid connection */
  Plaid = 'PLAID',
  /** Spade Transaction Enrichment */
  Spade = 'SPADE',
}

export type TransactionSources = PlaidTransaction | SpadeTransaction

/** Represents the pending, posted, or projected status for a transaction */
export enum TransactionStatus {
  /** Awaiting decision or settlement, may be replaced, updated, or removed */
  Pending = 'PENDING',
  /** Announced or published as conclusive */
  Posted = 'POSTED',
  /** Estimated or forecast on the basis of current trends or data */
  Projected = 'PROJECTED',
}

/** Autogenerated input type of TransactionUpdate */
export type TransactionUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
}

/** Autogenerated return type of TransactionUpdate */
export type TransactionUpdatePayload = {
  __typename?: 'TransactionUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated Account Information */
  record?: Maybe<Account>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

export type BillsQueryVariables = Exact<{ [key: string]: never }>

export type BillsQuery = {
  __typename?: 'Query'
  recurrences?:
    | Array<{
        __typename?: 'Recurrence'
        id: string
        name?: string | null | undefined
        frequency: RecurrenceFrequency
        state: LedgerState
        transactionNext?:
          | { __typename?: 'Transaction'; id: string; date: any; amount: number }
          | null
          | undefined
      }>
    | null
    | undefined
}

export type BillDetailQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type BillDetailQuery = {
  __typename?: 'Query'
  recurrence?:
    | {
        __typename?: 'Recurrence'
        id: string
        name?: string | null | undefined
        frequency: RecurrenceFrequency
        state: LedgerState
        transactionNext?:
          | { __typename?: 'Transaction'; id: string; date: any; amount: number }
          | null
          | undefined
        transactions: Array<{ __typename?: 'Transaction'; id: string; amount: number; date: any }>
      }
    | null
    | undefined
}

export type BillTemplateQueryVariables = Exact<{
  categoryId?: Maybe<Scalars['ID']>
  merchantId?: Maybe<Scalars['ID']>
  name?: Maybe<Scalars['String']>
}>

export type BillTemplateQuery = {
  __typename?: 'Query'
  recurrences?:
    | Array<{ __typename?: 'Recurrence'; name?: string | null | undefined }>
    | null
    | undefined
}

export type CreateBillMutationVariables = Exact<{
  input: RecurrenceCreateInput
}>

export type CreateBillMutation = {
  __typename?: 'Mutation'
  recurrenceCreate?:
    | {
        __typename?: 'RecurrenceCreatePayload'
        record?:
          | {
              __typename?: 'Recurrence'
              id: string
              name?: string | null | undefined
              frequency: RecurrenceFrequency
              state: LedgerState
            }
          | null
          | undefined
        errors?:
          | Array<{
              __typename?: 'Error'
              message?: string | null | undefined
              path?: Array<string> | null | undefined
            }>
          | null
          | undefined
      }
    | null
    | undefined
}

export type UpdateBillMutationVariables = Exact<{
  input: RecurrenceUpdateInput
}>

export type UpdateBillMutation = {
  __typename?: 'Mutation'
  recurrenceUpdate?:
    | {
        __typename?: 'RecurrenceUpdatePayload'
        record?:
          | {
              __typename?: 'Recurrence'
              id: string
              name?: string | null | undefined
              frequency: RecurrenceFrequency
              state: LedgerState
            }
          | null
          | undefined
        errors?:
          | Array<{
              __typename?: 'Error'
              message?: string | null | undefined
              path?: Array<string> | null | undefined
            }>
          | null
          | undefined
      }
    | null
    | undefined
}

export type PlaidItemsQueryVariables = Exact<{ [key: string]: never }>

export type PlaidItemsQuery = {
  __typename?: 'Query'
  plaidItems?:
    | Array<{
        __typename?: 'PlaidItem'
        id: string
        name: string
        status: PlaidItemStatus
        syncedAt?: any | null | undefined
        logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
        accounts: Array<{
          __typename?: 'Account'
          id: string
          name: string
          lastFourDigits?: string | null | undefined
          type: AccountType
          balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
        }>
      }>
    | null
    | undefined
}

export type PlaidItemSyncStatusQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type PlaidItemSyncStatusQuery = {
  __typename?: 'Query'
  plaidItem?:
    | {
        __typename?: 'PlaidItem'
        id: string
        status: PlaidItemStatus
        syncedAt?: any | null | undefined
      }
    | null
    | undefined
}

export type PlaidLinkTokenCreateMutationVariables = Exact<{
  input: PlaidLinkTokenCreateInput
}>

export type PlaidLinkTokenCreateMutation = {
  __typename?: 'Mutation'
  plaidLinkTokenCreate?:
    | {
        __typename?: 'PlaidLinkTokenCreatePayload'
        record?:
          | { __typename?: 'PlaidLinkToken'; linkToken: string; expiration: any }
          | null
          | undefined
        errors?:
          | Array<{
              __typename?: 'PlaidAPIError'
              code: string
              type: string
              message: string
              requestId?: string | null | undefined
              displayMessage?: string | null | undefined
            }>
          | null
          | undefined
      }
    | null
    | undefined
}

export type PlaidLinkTokenCreateForUpdateMutationVariables = Exact<{
  input: PlaidLinkTokenCreateForUpdateInput
}>

export type PlaidLinkTokenCreateForUpdateMutation = {
  __typename?: 'Mutation'
  plaidLinkTokenCreateForUpdate?:
    | {
        __typename?: 'PlaidLinkTokenCreateForUpdatePayload'
        record?:
          | { __typename?: 'PlaidLinkToken'; linkToken: string; expiration: any }
          | null
          | undefined
        errors?:
          | Array<{
              __typename?: 'PlaidAPIError'
              code: string
              type: string
              message: string
              requestId?: string | null | undefined
              displayMessage?: string | null | undefined
            }>
          | null
          | undefined
      }
    | null
    | undefined
}

export type PlaidItemCreateMutationVariables = Exact<{
  input: PlaidItemCreateInput
}>

export type PlaidItemCreateMutation = {
  __typename?: 'Mutation'
  plaidItemCreate?:
    | {
        __typename?: 'PlaidItemCreatePayload'
        record?:
          | {
              __typename?: 'PlaidItem'
              id: string
              name: string
              status: PlaidItemStatus
              syncedAt?: any | null | undefined
              logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
              accounts: Array<{
                __typename?: 'Account'
                id: string
                name: string
                lastFourDigits?: string | null | undefined
                type: AccountType
                balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
              }>
            }
          | null
          | undefined
        errors?:
          | Array<{ __typename?: 'PlaidAPIError'; displayMessage?: string | null | undefined }>
          | null
          | undefined
      }
    | null
    | undefined
}

export type PlaidItemUnlinkMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type PlaidItemUnlinkMutation = {
  __typename?: 'Mutation'
  plaidItemDelete?:
    | {
        __typename?: 'PlaidItemDeletePayload'
        success: boolean
        record?: { __typename?: 'PlaidItem'; id: string } | null | undefined
      }
    | null
    | undefined
}

export type PlaidItemUpdatedSubscriptionVariables = Exact<{
  id: Scalars['ID']
}>

export type PlaidItemUpdatedSubscription = {
  __typename?: 'Subscription'
  plaidItemUpdated: {
    __typename?: 'PlaidItemUpdatedPayload'
    record?:
      | {
          __typename?: 'PlaidItem'
          id: string
          name: string
          status: PlaidItemStatus
          syncedAt?: any | null | undefined
          logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
          accounts: Array<{
            __typename?: 'Account'
            id: string
            name: string
            lastFourDigits?: string | null | undefined
            type: AccountType
            balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
          }>
        }
      | null
      | undefined
  }
}

export type NextPaycheckQueryQueryVariables = Exact<{ [key: string]: never }>

export type NextPaycheckQueryQuery = {
  __typename?: 'Query'
  profile?: { __typename?: 'Profile'; name?: string | null | undefined } | null | undefined
}

export type RoundUpActivateMutationVariables = Exact<{
  id: Scalars['ID']
  startAt: Scalars['DateTime']
  startOn?: Maybe<Scalars['Date']>
}>

export type RoundUpActivateMutation = {
  __typename?: 'Mutation'
  roundUpSetStartTime?:
    | {
        __typename?: 'RoundUpSetStartTimePayload'
        success: boolean
        record?:
          | {
              __typename?: 'RoundUp'
              id: string
              balance: {
                __typename?: 'LedgerBalance'
                id: string
                available?: number | null | undefined
              }
              transactionsConnection: {
                __typename?: 'TransactionConnection'
                nodes?:
                  | Array<
                      | {
                          __typename?: 'Transaction'
                          id: string
                          date: any
                          amount: number
                          description: string
                        }
                      | null
                      | undefined
                    >
                  | null
                  | undefined
              }
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type RoundUpActivateDateSearchQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpActivateDateSearchQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        subscribedAccounts: Array<{
          __typename?: 'Account'
          id: string
          transactions: Array<{
            __typename?: 'Transaction'
            id: string
            date: any
            amount: number
            status: TransactionStatus
          }>
        }>
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsAccountsListQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  bankConnectionId: Scalars['ID']
}>

export type RoundUpsBankConnectionsAccountsListQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
            }
          | null
          | undefined
      }
    | null
    | undefined
  plaidItem?:
    | {
        __typename?: 'PlaidItem'
        id: string
        name: string
        status: PlaidItemStatus
        syncedAt?: any | null | undefined
        logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
        accounts: Array<{ __typename?: 'Account'; id: string; name: string }>
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsAccountsListItemQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  accountId: Scalars['ID']
}>

export type RoundUpsBankConnectionsAccountsListItemQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
            }
          | null
          | undefined
        subscribedAccounts: Array<{ __typename?: 'Account'; id: string }>
        availableAccounts: Array<{ __typename?: 'Account'; id: string }>
      }
    | null
    | undefined
  account?:
    | {
        __typename?: 'Account'
        id: string
        name: string
        lastFourDigits?: string | null | undefined
        balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
      }
    | null
    | undefined
}

export type RoundUpsAccountsSubscribeMutationVariables = Exact<{
  id: Scalars['ID']
  accountId: Scalars['ID']
}>

export type RoundUpsAccountsSubscribeMutation = {
  __typename?: 'Mutation'
  roundUpSubscribedAccountsAdd?:
    | {
        __typename?: 'RoundUpSubscribedAccountsAddPayload'
        record?:
          | {
              __typename?: 'RoundUp'
              id: string
              subscribedAccounts: Array<{ __typename?: 'Account'; id: string }>
              availableAccounts: Array<{ __typename?: 'Account'; id: string }>
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type RoundUpsAccountsUnsubscribeMutationVariables = Exact<{
  id: Scalars['ID']
  accountId: Scalars['ID']
}>

export type RoundUpsAccountsUnsubscribeMutation = {
  __typename?: 'Mutation'
  roundUpSubscribedAccountsRemove?:
    | {
        __typename?: 'RoundUpSubscribedAccountsRemovePayload'
        record?:
          | {
              __typename?: 'RoundUp'
              id: string
              subscribedAccounts: Array<{ __typename?: 'Account'; id: string }>
              availableAccounts: Array<{ __typename?: 'Account'; id: string }>
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsAddFundingMutationVariables = Exact<{
  roundUpId: Scalars['ID']
  accountId: Scalars['ID']
}>

export type RoundUpsBankConnectionsAddFundingMutation = {
  __typename?: 'Mutation'
  roundUpSetFundingAccount?:
    | {
        __typename?: 'RoundUpSetFundingAccountPayload'
        success: boolean
        record?: { __typename?: 'RoundUp'; id: string } | null | undefined
      }
    | null
    | undefined
  roundUpSubscribedAccountsAdd?:
    | {
        __typename?: 'RoundUpSubscribedAccountsAddPayload'
        success: boolean
        record?: { __typename?: 'RoundUp'; id: string } | null | undefined
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsAddSubscriptionMutationVariables = Exact<{
  roundUpId: Scalars['ID']
  accountIds: Array<Scalars['ID']> | Scalars['ID']
}>

export type RoundUpsBankConnectionsAddSubscriptionMutation = {
  __typename?: 'Mutation'
  roundUpSubscribedAccountsAdd?:
    | {
        __typename?: 'RoundUpSubscribedAccountsAddPayload'
        success: boolean
        record?: { __typename?: 'RoundUp'; id: string } | null | undefined
      }
    | null
    | undefined
}

export type RoundUpsRecentActivityQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  since: Scalars['Date']
}>

export type RoundUpsRecentActivityQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        recentActivity: {
          __typename?: 'LedgerBalance'
          id: string
          current?: number | null | undefined
        }
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsSummaryCardFooterQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpsBankConnectionsSummaryCardFooterQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsSummaryCardHeaderQueryVariables = Exact<{ [key: string]: never }>

export type RoundUpsBankConnectionsSummaryCardHeaderQuery = {
  __typename?: 'Query'
  plaidItems?: Array<{ __typename?: 'PlaidItem'; id: string }> | null | undefined
}

export type RoundUpsBankConnectionsCardQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  id: Scalars['ID']
}>

export type RoundUpsBankConnectionsCardQuery = {
  __typename?: 'Query'
  roundUp?: { __typename?: 'RoundUp'; id: string } | null | undefined
  plaidItem?:
    | {
        __typename?: 'PlaidItem'
        id: string
        name: string
        status: PlaidItemStatus
        syncedAt?: any | null | undefined
        logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsListQueryVariables = Exact<{
  roundUpId: Scalars['ID']
}>

export type RoundUpsBankConnectionsListQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              lastFourDigits?: string | null | undefined
              name: string
              type: AccountType
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
              plaidItem?: { __typename?: 'PlaidItem'; id: string } | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
  plaidItems?:
    | Array<{
        __typename?: 'PlaidItem'
        id: string
        name: string
        status: PlaidItemStatus
        syncedAt?: any | null | undefined
        logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
      }>
    | null
    | undefined
}

export type RoundUpsBankConnectionsListItemQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  id: Scalars['ID']
}>

export type RoundUpsBankConnectionsListItemQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              lastFourDigits?: string | null | undefined
              name: string
              type: AccountType
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
              plaidItem?: { __typename?: 'PlaidItem'; id: string } | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
  plaidItem?:
    | {
        __typename?: 'PlaidItem'
        id: string
        name: string
        status: PlaidItemStatus
        syncedAt?: any | null | undefined
        logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsPageQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpsBankConnectionsPageQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
            }
          | null
          | undefined
      }
    | null
    | undefined
  plaidItems?:
    | Array<{
        __typename?: 'PlaidItem'
        id: string
        status: PlaidItemStatus
        syncedAt?: any | null | undefined
        accounts: Array<{ __typename?: 'Account'; id: string }>
      }>
    | null
    | undefined
}

export type RoundUpsPauseMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpsPauseMutation = {
  __typename?: 'Mutation'
  roundUpPause?:
    | {
        __typename?: 'RoundUpPausePayload'
        record?: { __typename?: 'RoundUp'; id: string; status: LedgerStatus } | null | undefined
      }
    | null
    | undefined
}

export type RoundUpsResumeMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpsResumeMutation = {
  __typename?: 'Mutation'
  roundUpResume?:
    | {
        __typename?: 'RoundUpResumePayload'
        record?: { __typename?: 'RoundUp'; id: string; status: LedgerStatus } | null | undefined
      }
    | null
    | undefined
}

export type RoundUpSummaryQueryVariables = Exact<{
  id: Scalars['ID']
  startOfWeek?: Maybe<Scalars['Date']>
}>

export type RoundUpSummaryQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        totalAmount: {
          __typename?: 'LedgerBalance'
          id: string
          available?: number | null | undefined
          current?: number | null | undefined
        }
        thisWeek: {
          __typename?: 'LedgerBalance'
          id: string
          available?: number | null | undefined
          current?: number | null | undefined
        }
      }
    | null
    | undefined
}

export type RoundUpHistoryQueryVariables = Exact<{
  id: Scalars['ID']
  day0: Scalars['Date']
  day1: Scalars['Date']
  day2: Scalars['Date']
  day3: Scalars['Date']
  day4: Scalars['Date']
  day5: Scalars['Date']
  day6: Scalars['Date']
}>

export type RoundUpHistoryQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        day0: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
        day1: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
        day2: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
        day3: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
        day4: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
        day5: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
        day6: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
      }
    | null
    | undefined
}

export type RoundUpTransactionsQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpTransactionsQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        transactionsConnection: {
          __typename?: 'TransactionConnection'
          edges?:
            | Array<
                | {
                    __typename?: 'TransactionEdge'
                    node?:
                      | {
                          __typename?: 'Transaction'
                          id: string
                          date: any
                          amount: number
                          description: string
                        }
                      | null
                      | undefined
                  }
                | null
                | undefined
              >
            | null
            | undefined
        }
      }
    | null
    | undefined
}

export type RoundUpsQueryVariables = Exact<{ [key: string]: never }>

export type RoundUpsQuery = {
  __typename?: 'Query'
  roundUps?: Array<{ __typename?: 'RoundUp'; id: string }> | null | undefined
}

export type RoundUpHomeQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpHomeQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        status: LedgerStatus
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type CreateRoundUpMutationVariables = Exact<{ [key: string]: never }>

export type CreateRoundUpMutation = {
  __typename?: 'Mutation'
  roundUpCreate?:
    | {
        __typename?: 'RoundUpCreatePayload'
        success: boolean
        record?: { __typename?: 'RoundUp'; id: string; status: LedgerStatus } | null | undefined
      }
    | null
    | undefined
}

export type ProfileFragmentFragment = {
  __typename?: 'Profile'
  name?: string | null | undefined
  email?: string | null | undefined
  phone?: string | null | undefined
}

export type ProfileQueryVariables = Exact<{ [key: string]: never }>

export type ProfileQuery = {
  __typename?: 'Query'
  profile?:
    | {
        __typename?: 'Profile'
        name?: string | null | undefined
        email?: string | null | undefined
        phone?: string | null | undefined
      }
    | null
    | undefined
}

export type ProfileUpdateMutationVariables = Exact<{
  input: ProfileUpdateInput
}>

export type ProfileUpdateMutation = {
  __typename?: 'Mutation'
  profileUpdate?:
    | {
        __typename?: 'ProfileUpdatePayload'
        record?:
          | {
              __typename?: 'Profile'
              name?: string | null | undefined
              email?: string | null | undefined
              phone?: string | null | undefined
            }
          | null
          | undefined
        errors?:
          | Array<{
              __typename?: 'Error'
              path?: Array<string> | null | undefined
              message?: string | null | undefined
            }>
          | null
          | undefined
      }
    | null
    | undefined
}

export type AccountFragmentFragment = {
  __typename?: 'Account'
  id: string
  lastFourDigits?: string | null | undefined
  name: string
  type: AccountType
  plaidItem?: { __typename?: 'PlaidItem'; id: string } | null | undefined
}

export type PlaidItemFragmentFragment = {
  __typename?: 'PlaidItem'
  id: string
  name: string
  status: PlaidItemStatus
  syncedAt?: any | null | undefined
  logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
  accounts: Array<{
    __typename?: 'Account'
    id: string
    name: string
    lastFourDigits?: string | null | undefined
    type: AccountType
    balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
  }>
}

export const ProfileFragmentFragmentDoc = gql`
  fragment ProfileFragment on Profile {
    name
    email
    phone
  }
`
export const AccountFragmentFragmentDoc = gql`
  fragment AccountFragment on Account {
    id
    lastFourDigits
    name
    type
    plaidItem {
      id
    }
  }
`
export const PlaidItemFragmentFragmentDoc = gql`
  fragment PlaidItemFragment on PlaidItem {
    id
    name
    logo {
      url
    }
    status
    syncedAt
    accounts {
      id
      name
      balance {
        current
      }
      lastFourDigits
      type
    }
  }
`
export const BillsDocument = gql`
  query Bills {
    recurrences {
      id
      name
      frequency
      state
      transactionNext {
        id
        date
        amount
      }
    }
  }
`

/**
 * __useBillsQuery__
 *
 * To run a query within a React component, call `useBillsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBillsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBillsQuery({
 *   variables: {
 *   },
 * });
 */
export function useBillsQuery(
  baseOptions?: Apollo.QueryHookOptions<BillsQuery, BillsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<BillsQuery, BillsQueryVariables>(BillsDocument, options)
}
export function useBillsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<BillsQuery, BillsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<BillsQuery, BillsQueryVariables>(BillsDocument, options)
}
export type BillsQueryHookResult = ReturnType<typeof useBillsQuery>
export type BillsLazyQueryHookResult = ReturnType<typeof useBillsLazyQuery>
export type BillsQueryResult = Apollo.QueryResult<BillsQuery, BillsQueryVariables>
export const BillDetailDocument = gql`
  query BillDetail($id: ID!) {
    recurrence(id: $id) {
      id
      name
      frequency
      state
      transactionNext {
        id
        date
        amount
      }
      transactions {
        id
        amount
        date
      }
    }
  }
`

/**
 * __useBillDetailQuery__
 *
 * To run a query within a React component, call `useBillDetailQuery` and pass it any options that fit your needs.
 * When your component renders, `useBillDetailQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBillDetailQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useBillDetailQuery(
  baseOptions: Apollo.QueryHookOptions<BillDetailQuery, BillDetailQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<BillDetailQuery, BillDetailQueryVariables>(BillDetailDocument, options)
}
export function useBillDetailLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<BillDetailQuery, BillDetailQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<BillDetailQuery, BillDetailQueryVariables>(BillDetailDocument, options)
}
export type BillDetailQueryHookResult = ReturnType<typeof useBillDetailQuery>
export type BillDetailLazyQueryHookResult = ReturnType<typeof useBillDetailLazyQuery>
export type BillDetailQueryResult = Apollo.QueryResult<BillDetailQuery, BillDetailQueryVariables>
export const BillTemplateDocument = gql`
  query BillTemplate($categoryId: ID, $merchantId: ID, $name: String) {
    recurrences {
      name
    }
  }
`

/**
 * __useBillTemplateQuery__
 *
 * To run a query within a React component, call `useBillTemplateQuery` and pass it any options that fit your needs.
 * When your component renders, `useBillTemplateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBillTemplateQuery({
 *   variables: {
 *      categoryId: // value for 'categoryId'
 *      merchantId: // value for 'merchantId'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useBillTemplateQuery(
  baseOptions?: Apollo.QueryHookOptions<BillTemplateQuery, BillTemplateQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<BillTemplateQuery, BillTemplateQueryVariables>(
    BillTemplateDocument,
    options
  )
}
export function useBillTemplateLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<BillTemplateQuery, BillTemplateQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<BillTemplateQuery, BillTemplateQueryVariables>(
    BillTemplateDocument,
    options
  )
}
export type BillTemplateQueryHookResult = ReturnType<typeof useBillTemplateQuery>
export type BillTemplateLazyQueryHookResult = ReturnType<typeof useBillTemplateLazyQuery>
export type BillTemplateQueryResult = Apollo.QueryResult<
  BillTemplateQuery,
  BillTemplateQueryVariables
>
export const CreateBillDocument = gql`
  mutation CreateBill($input: RecurrenceCreateInput!) {
    recurrenceCreate(input: $input) {
      record {
        id
        name
        frequency
        state
      }
      errors {
        message
        path
      }
    }
  }
`
export type CreateBillMutationFn = Apollo.MutationFunction<
  CreateBillMutation,
  CreateBillMutationVariables
>

/**
 * __useCreateBillMutation__
 *
 * To run a mutation, you first call `useCreateBillMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateBillMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createBillMutation, { data, loading, error }] = useCreateBillMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateBillMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateBillMutation, CreateBillMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateBillMutation, CreateBillMutationVariables>(
    CreateBillDocument,
    options
  )
}
export type CreateBillMutationHookResult = ReturnType<typeof useCreateBillMutation>
export type CreateBillMutationResult = Apollo.MutationResult<CreateBillMutation>
export type CreateBillMutationOptions = Apollo.BaseMutationOptions<
  CreateBillMutation,
  CreateBillMutationVariables
>
export const UpdateBillDocument = gql`
  mutation UpdateBill($input: RecurrenceUpdateInput!) {
    recurrenceUpdate(input: $input) {
      record {
        id
        name
        frequency
        state
      }
      errors {
        message
        path
      }
    }
  }
`
export type UpdateBillMutationFn = Apollo.MutationFunction<
  UpdateBillMutation,
  UpdateBillMutationVariables
>

/**
 * __useUpdateBillMutation__
 *
 * To run a mutation, you first call `useUpdateBillMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillMutation, { data, loading, error }] = useUpdateBillMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillMutation(
  baseOptions?: Apollo.MutationHookOptions<UpdateBillMutation, UpdateBillMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UpdateBillMutation, UpdateBillMutationVariables>(
    UpdateBillDocument,
    options
  )
}
export type UpdateBillMutationHookResult = ReturnType<typeof useUpdateBillMutation>
export type UpdateBillMutationResult = Apollo.MutationResult<UpdateBillMutation>
export type UpdateBillMutationOptions = Apollo.BaseMutationOptions<
  UpdateBillMutation,
  UpdateBillMutationVariables
>
export const PlaidItemsDocument = gql`
  query PlaidItems {
    plaidItems {
      ...PlaidItemFragment
    }
  }
  ${PlaidItemFragmentFragmentDoc}
`

/**
 * __usePlaidItemsQuery__
 *
 * To run a query within a React component, call `usePlaidItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlaidItemsQuery({
 *   variables: {
 *   },
 * });
 */
export function usePlaidItemsQuery(
  baseOptions?: Apollo.QueryHookOptions<PlaidItemsQuery, PlaidItemsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<PlaidItemsQuery, PlaidItemsQueryVariables>(PlaidItemsDocument, options)
}
export function usePlaidItemsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<PlaidItemsQuery, PlaidItemsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<PlaidItemsQuery, PlaidItemsQueryVariables>(PlaidItemsDocument, options)
}
export type PlaidItemsQueryHookResult = ReturnType<typeof usePlaidItemsQuery>
export type PlaidItemsLazyQueryHookResult = ReturnType<typeof usePlaidItemsLazyQuery>
export type PlaidItemsQueryResult = Apollo.QueryResult<PlaidItemsQuery, PlaidItemsQueryVariables>
export const PlaidItemSyncStatusDocument = gql`
  query PlaidItemSyncStatus($id: ID!) {
    plaidItem(id: $id) {
      id
      status
      syncedAt
    }
  }
`

/**
 * __usePlaidItemSyncStatusQuery__
 *
 * To run a query within a React component, call `usePlaidItemSyncStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemSyncStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlaidItemSyncStatusQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlaidItemSyncStatusQuery(
  baseOptions: Apollo.QueryHookOptions<PlaidItemSyncStatusQuery, PlaidItemSyncStatusQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<PlaidItemSyncStatusQuery, PlaidItemSyncStatusQueryVariables>(
    PlaidItemSyncStatusDocument,
    options
  )
}
export function usePlaidItemSyncStatusLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    PlaidItemSyncStatusQuery,
    PlaidItemSyncStatusQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<PlaidItemSyncStatusQuery, PlaidItemSyncStatusQueryVariables>(
    PlaidItemSyncStatusDocument,
    options
  )
}
export type PlaidItemSyncStatusQueryHookResult = ReturnType<typeof usePlaidItemSyncStatusQuery>
export type PlaidItemSyncStatusLazyQueryHookResult = ReturnType<
  typeof usePlaidItemSyncStatusLazyQuery
>
export type PlaidItemSyncStatusQueryResult = Apollo.QueryResult<
  PlaidItemSyncStatusQuery,
  PlaidItemSyncStatusQueryVariables
>
export const PlaidLinkTokenCreateDocument = gql`
  mutation PlaidLinkTokenCreate($input: PlaidLinkTokenCreateInput!) {
    plaidLinkTokenCreate(input: $input) {
      record {
        linkToken
        expiration
      }
      errors {
        code
        type
        message
        requestId
        displayMessage
      }
    }
  }
`
export type PlaidLinkTokenCreateMutationFn = Apollo.MutationFunction<
  PlaidLinkTokenCreateMutation,
  PlaidLinkTokenCreateMutationVariables
>

/**
 * __usePlaidLinkTokenCreateMutation__
 *
 * To run a mutation, you first call `usePlaidLinkTokenCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlaidLinkTokenCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [plaidLinkTokenCreateMutation, { data, loading, error }] = usePlaidLinkTokenCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlaidLinkTokenCreateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PlaidLinkTokenCreateMutation,
    PlaidLinkTokenCreateMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<PlaidLinkTokenCreateMutation, PlaidLinkTokenCreateMutationVariables>(
    PlaidLinkTokenCreateDocument,
    options
  )
}
export type PlaidLinkTokenCreateMutationHookResult = ReturnType<
  typeof usePlaidLinkTokenCreateMutation
>
export type PlaidLinkTokenCreateMutationResult = Apollo.MutationResult<PlaidLinkTokenCreateMutation>
export type PlaidLinkTokenCreateMutationOptions = Apollo.BaseMutationOptions<
  PlaidLinkTokenCreateMutation,
  PlaidLinkTokenCreateMutationVariables
>
export const PlaidLinkTokenCreateForUpdateDocument = gql`
  mutation PlaidLinkTokenCreateForUpdate($input: PlaidLinkTokenCreateForUpdateInput!) {
    plaidLinkTokenCreateForUpdate(input: $input) {
      record {
        linkToken
        expiration
      }
      errors {
        code
        type
        message
        requestId
        displayMessage
      }
    }
  }
`
export type PlaidLinkTokenCreateForUpdateMutationFn = Apollo.MutationFunction<
  PlaidLinkTokenCreateForUpdateMutation,
  PlaidLinkTokenCreateForUpdateMutationVariables
>

/**
 * __usePlaidLinkTokenCreateForUpdateMutation__
 *
 * To run a mutation, you first call `usePlaidLinkTokenCreateForUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlaidLinkTokenCreateForUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [plaidLinkTokenCreateForUpdateMutation, { data, loading, error }] = usePlaidLinkTokenCreateForUpdateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlaidLinkTokenCreateForUpdateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PlaidLinkTokenCreateForUpdateMutation,
    PlaidLinkTokenCreateForUpdateMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    PlaidLinkTokenCreateForUpdateMutation,
    PlaidLinkTokenCreateForUpdateMutationVariables
  >(PlaidLinkTokenCreateForUpdateDocument, options)
}
export type PlaidLinkTokenCreateForUpdateMutationHookResult = ReturnType<
  typeof usePlaidLinkTokenCreateForUpdateMutation
>
export type PlaidLinkTokenCreateForUpdateMutationResult =
  Apollo.MutationResult<PlaidLinkTokenCreateForUpdateMutation>
export type PlaidLinkTokenCreateForUpdateMutationOptions = Apollo.BaseMutationOptions<
  PlaidLinkTokenCreateForUpdateMutation,
  PlaidLinkTokenCreateForUpdateMutationVariables
>
export const PlaidItemCreateDocument = gql`
  mutation PlaidItemCreate($input: PlaidItemCreateInput!) {
    plaidItemCreate(input: $input) {
      record {
        ...PlaidItemFragment
      }
      errors {
        displayMessage
      }
    }
  }
  ${PlaidItemFragmentFragmentDoc}
`
export type PlaidItemCreateMutationFn = Apollo.MutationFunction<
  PlaidItemCreateMutation,
  PlaidItemCreateMutationVariables
>

/**
 * __usePlaidItemCreateMutation__
 *
 * To run a mutation, you first call `usePlaidItemCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [plaidItemCreateMutation, { data, loading, error }] = usePlaidItemCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlaidItemCreateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PlaidItemCreateMutation,
    PlaidItemCreateMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<PlaidItemCreateMutation, PlaidItemCreateMutationVariables>(
    PlaidItemCreateDocument,
    options
  )
}
export type PlaidItemCreateMutationHookResult = ReturnType<typeof usePlaidItemCreateMutation>
export type PlaidItemCreateMutationResult = Apollo.MutationResult<PlaidItemCreateMutation>
export type PlaidItemCreateMutationOptions = Apollo.BaseMutationOptions<
  PlaidItemCreateMutation,
  PlaidItemCreateMutationVariables
>
export const PlaidItemUnlinkDocument = gql`
  mutation PlaidItemUnlink($id: ID!) {
    plaidItemDelete(input: { id: $id }) {
      success
      record {
        id
      }
    }
  }
`
export type PlaidItemUnlinkMutationFn = Apollo.MutationFunction<
  PlaidItemUnlinkMutation,
  PlaidItemUnlinkMutationVariables
>

/**
 * __usePlaidItemUnlinkMutation__
 *
 * To run a mutation, you first call `usePlaidItemUnlinkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemUnlinkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [plaidItemUnlinkMutation, { data, loading, error }] = usePlaidItemUnlinkMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlaidItemUnlinkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PlaidItemUnlinkMutation,
    PlaidItemUnlinkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<PlaidItemUnlinkMutation, PlaidItemUnlinkMutationVariables>(
    PlaidItemUnlinkDocument,
    options
  )
}
export type PlaidItemUnlinkMutationHookResult = ReturnType<typeof usePlaidItemUnlinkMutation>
export type PlaidItemUnlinkMutationResult = Apollo.MutationResult<PlaidItemUnlinkMutation>
export type PlaidItemUnlinkMutationOptions = Apollo.BaseMutationOptions<
  PlaidItemUnlinkMutation,
  PlaidItemUnlinkMutationVariables
>
export const PlaidItemUpdatedDocument = gql`
  subscription PlaidItemUpdated($id: ID!) {
    plaidItemUpdated(id: $id) {
      record {
        ...PlaidItemFragment
      }
    }
  }
  ${PlaidItemFragmentFragmentDoc}
`

/**
 * __usePlaidItemUpdatedSubscription__
 *
 * To run a query within a React component, call `usePlaidItemUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlaidItemUpdatedSubscription({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlaidItemUpdatedSubscription(
  baseOptions: Apollo.SubscriptionHookOptions<
    PlaidItemUpdatedSubscription,
    PlaidItemUpdatedSubscriptionVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSubscription<
    PlaidItemUpdatedSubscription,
    PlaidItemUpdatedSubscriptionVariables
  >(PlaidItemUpdatedDocument, options)
}
export type PlaidItemUpdatedSubscriptionHookResult = ReturnType<
  typeof usePlaidItemUpdatedSubscription
>
export type PlaidItemUpdatedSubscriptionResult =
  Apollo.SubscriptionResult<PlaidItemUpdatedSubscription>
export const NextPaycheckQueryDocument = gql`
  query NextPaycheckQuery {
    profile {
      name
    }
  }
`

/**
 * __useNextPaycheckQueryQuery__
 *
 * To run a query within a React component, call `useNextPaycheckQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useNextPaycheckQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNextPaycheckQueryQuery({
 *   variables: {
 *   },
 * });
 */
export function useNextPaycheckQueryQuery(
  baseOptions?: Apollo.QueryHookOptions<NextPaycheckQueryQuery, NextPaycheckQueryQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<NextPaycheckQueryQuery, NextPaycheckQueryQueryVariables>(
    NextPaycheckQueryDocument,
    options
  )
}
export function useNextPaycheckQueryLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<NextPaycheckQueryQuery, NextPaycheckQueryQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<NextPaycheckQueryQuery, NextPaycheckQueryQueryVariables>(
    NextPaycheckQueryDocument,
    options
  )
}
export type NextPaycheckQueryQueryHookResult = ReturnType<typeof useNextPaycheckQueryQuery>
export type NextPaycheckQueryLazyQueryHookResult = ReturnType<typeof useNextPaycheckQueryLazyQuery>
export type NextPaycheckQueryQueryResult = Apollo.QueryResult<
  NextPaycheckQueryQuery,
  NextPaycheckQueryQueryVariables
>
export const RoundUpActivateDocument = gql`
  mutation RoundUpActivate($id: ID!, $startAt: DateTime!, $startOn: Date) {
    roundUpSetStartTime(input: { id: $id, startAt: $startAt }) {
      success
      record {
        id
        balance(filter: { date_gte: $startOn }) {
          id
          available
        }
        transactionsConnection(filter: { date_gte: $startOn }) {
          nodes {
            id
            date
            amount
            description
          }
        }
      }
    }
  }
`
export type RoundUpActivateMutationFn = Apollo.MutationFunction<
  RoundUpActivateMutation,
  RoundUpActivateMutationVariables
>

/**
 * __useRoundUpActivateMutation__
 *
 * To run a mutation, you first call `useRoundUpActivateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpActivateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpActivateMutation, { data, loading, error }] = useRoundUpActivateMutation({
 *   variables: {
 *      id: // value for 'id'
 *      startAt: // value for 'startAt'
 *      startOn: // value for 'startOn'
 *   },
 * });
 */
export function useRoundUpActivateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpActivateMutation,
    RoundUpActivateMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<RoundUpActivateMutation, RoundUpActivateMutationVariables>(
    RoundUpActivateDocument,
    options
  )
}
export type RoundUpActivateMutationHookResult = ReturnType<typeof useRoundUpActivateMutation>
export type RoundUpActivateMutationResult = Apollo.MutationResult<RoundUpActivateMutation>
export type RoundUpActivateMutationOptions = Apollo.BaseMutationOptions<
  RoundUpActivateMutation,
  RoundUpActivateMutationVariables
>
export const RoundUpActivateDateSearchDocument = gql`
  query RoundUpActivateDateSearch($id: ID!) {
    roundUp(id: $id) {
      id
      subscribedAccounts {
        id
        transactions(limit: 15, filter: { amount_lt: 0 }) {
          id
          date
          amount
          status
        }
      }
    }
  }
`

/**
 * __useRoundUpActivateDateSearchQuery__
 *
 * To run a query within a React component, call `useRoundUpActivateDateSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpActivateDateSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpActivateDateSearchQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpActivateDateSearchQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpActivateDateSearchQuery,
    RoundUpActivateDateSearchQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpActivateDateSearchQuery, RoundUpActivateDateSearchQueryVariables>(
    RoundUpActivateDateSearchDocument,
    options
  )
}
export function useRoundUpActivateDateSearchLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpActivateDateSearchQuery,
    RoundUpActivateDateSearchQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpActivateDateSearchQuery,
    RoundUpActivateDateSearchQueryVariables
  >(RoundUpActivateDateSearchDocument, options)
}
export type RoundUpActivateDateSearchQueryHookResult = ReturnType<
  typeof useRoundUpActivateDateSearchQuery
>
export type RoundUpActivateDateSearchLazyQueryHookResult = ReturnType<
  typeof useRoundUpActivateDateSearchLazyQuery
>
export type RoundUpActivateDateSearchQueryResult = Apollo.QueryResult<
  RoundUpActivateDateSearchQuery,
  RoundUpActivateDateSearchQueryVariables
>
export const RoundUpsBankConnectionsAccountsListDocument = gql`
  query RoundUpsBankConnectionsAccountsList($roundUpId: ID!, $bankConnectionId: ID!) {
    roundUp(id: $roundUpId) {
      id
      fundingAccount {
        id
        balance {
          current
        }
      }
    }
    plaidItem(id: $bankConnectionId) {
      id
      name
      logo {
        url
      }
      accounts {
        id
        name
      }
      status
      syncedAt
    }
  }
`

/**
 * __useRoundUpsBankConnectionsAccountsListQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsAccountsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsAccountsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsAccountsListQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      bankConnectionId: // value for 'bankConnectionId'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsAccountsListQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsAccountsListQuery,
    RoundUpsBankConnectionsAccountsListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsAccountsListQuery,
    RoundUpsBankConnectionsAccountsListQueryVariables
  >(RoundUpsBankConnectionsAccountsListDocument, options)
}
export function useRoundUpsBankConnectionsAccountsListLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsAccountsListQuery,
    RoundUpsBankConnectionsAccountsListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsAccountsListQuery,
    RoundUpsBankConnectionsAccountsListQueryVariables
  >(RoundUpsBankConnectionsAccountsListDocument, options)
}
export type RoundUpsBankConnectionsAccountsListQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAccountsListQuery
>
export type RoundUpsBankConnectionsAccountsListLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAccountsListLazyQuery
>
export type RoundUpsBankConnectionsAccountsListQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsAccountsListQuery,
  RoundUpsBankConnectionsAccountsListQueryVariables
>
export const RoundUpsBankConnectionsAccountsListItemDocument = gql`
  query RoundUpsBankConnectionsAccountsListItem($roundUpId: ID!, $accountId: ID!) {
    roundUp(id: $roundUpId) {
      id
      fundingAccount {
        id
        balance {
          current
        }
      }
      subscribedAccounts {
        id
      }
      availableAccounts {
        id
      }
    }
    account(id: $accountId) {
      id
      name
      lastFourDigits
      balance {
        current
      }
    }
  }
`

/**
 * __useRoundUpsBankConnectionsAccountsListItemQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsAccountsListItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsAccountsListItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsAccountsListItemQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsAccountsListItemQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsAccountsListItemQuery,
    RoundUpsBankConnectionsAccountsListItemQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsAccountsListItemQuery,
    RoundUpsBankConnectionsAccountsListItemQueryVariables
  >(RoundUpsBankConnectionsAccountsListItemDocument, options)
}
export function useRoundUpsBankConnectionsAccountsListItemLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsAccountsListItemQuery,
    RoundUpsBankConnectionsAccountsListItemQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsAccountsListItemQuery,
    RoundUpsBankConnectionsAccountsListItemQueryVariables
  >(RoundUpsBankConnectionsAccountsListItemDocument, options)
}
export type RoundUpsBankConnectionsAccountsListItemQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAccountsListItemQuery
>
export type RoundUpsBankConnectionsAccountsListItemLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAccountsListItemLazyQuery
>
export type RoundUpsBankConnectionsAccountsListItemQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsAccountsListItemQuery,
  RoundUpsBankConnectionsAccountsListItemQueryVariables
>
export const RoundUpsAccountsSubscribeDocument = gql`
  mutation RoundUpsAccountsSubscribe($id: ID!, $accountId: ID!) {
    roundUpSubscribedAccountsAdd(input: { id: $id, accountIds: [$accountId] }) {
      record {
        id
        subscribedAccounts {
          id
        }
        availableAccounts {
          id
        }
      }
    }
  }
`
export type RoundUpsAccountsSubscribeMutationFn = Apollo.MutationFunction<
  RoundUpsAccountsSubscribeMutation,
  RoundUpsAccountsSubscribeMutationVariables
>

/**
 * __useRoundUpsAccountsSubscribeMutation__
 *
 * To run a mutation, you first call `useRoundUpsAccountsSubscribeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsAccountsSubscribeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsAccountsSubscribeMutation, { data, loading, error }] = useRoundUpsAccountsSubscribeMutation({
 *   variables: {
 *      id: // value for 'id'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useRoundUpsAccountsSubscribeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsAccountsSubscribeMutation,
    RoundUpsAccountsSubscribeMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    RoundUpsAccountsSubscribeMutation,
    RoundUpsAccountsSubscribeMutationVariables
  >(RoundUpsAccountsSubscribeDocument, options)
}
export type RoundUpsAccountsSubscribeMutationHookResult = ReturnType<
  typeof useRoundUpsAccountsSubscribeMutation
>
export type RoundUpsAccountsSubscribeMutationResult =
  Apollo.MutationResult<RoundUpsAccountsSubscribeMutation>
export type RoundUpsAccountsSubscribeMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsAccountsSubscribeMutation,
  RoundUpsAccountsSubscribeMutationVariables
>
export const RoundUpsAccountsUnsubscribeDocument = gql`
  mutation RoundUpsAccountsUnsubscribe($id: ID!, $accountId: ID!) {
    roundUpSubscribedAccountsRemove(input: { id: $id, accountIds: [$accountId] }) {
      record {
        id
        subscribedAccounts {
          id
        }
        availableAccounts {
          id
        }
      }
    }
  }
`
export type RoundUpsAccountsUnsubscribeMutationFn = Apollo.MutationFunction<
  RoundUpsAccountsUnsubscribeMutation,
  RoundUpsAccountsUnsubscribeMutationVariables
>

/**
 * __useRoundUpsAccountsUnsubscribeMutation__
 *
 * To run a mutation, you first call `useRoundUpsAccountsUnsubscribeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsAccountsUnsubscribeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsAccountsUnsubscribeMutation, { data, loading, error }] = useRoundUpsAccountsUnsubscribeMutation({
 *   variables: {
 *      id: // value for 'id'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useRoundUpsAccountsUnsubscribeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsAccountsUnsubscribeMutation,
    RoundUpsAccountsUnsubscribeMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    RoundUpsAccountsUnsubscribeMutation,
    RoundUpsAccountsUnsubscribeMutationVariables
  >(RoundUpsAccountsUnsubscribeDocument, options)
}
export type RoundUpsAccountsUnsubscribeMutationHookResult = ReturnType<
  typeof useRoundUpsAccountsUnsubscribeMutation
>
export type RoundUpsAccountsUnsubscribeMutationResult =
  Apollo.MutationResult<RoundUpsAccountsUnsubscribeMutation>
export type RoundUpsAccountsUnsubscribeMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsAccountsUnsubscribeMutation,
  RoundUpsAccountsUnsubscribeMutationVariables
>
export const RoundUpsBankConnectionsAddFundingDocument = gql`
  mutation RoundUpsBankConnectionsAddFunding($roundUpId: ID!, $accountId: ID!) {
    roundUpSetFundingAccount(input: { id: $roundUpId, accountId: $accountId }) {
      success
      record {
        id
      }
    }
    roundUpSubscribedAccountsAdd(input: { id: $roundUpId, accountIds: [$accountId] }) {
      success
      record {
        id
      }
    }
  }
`
export type RoundUpsBankConnectionsAddFundingMutationFn = Apollo.MutationFunction<
  RoundUpsBankConnectionsAddFundingMutation,
  RoundUpsBankConnectionsAddFundingMutationVariables
>

/**
 * __useRoundUpsBankConnectionsAddFundingMutation__
 *
 * To run a mutation, you first call `useRoundUpsBankConnectionsAddFundingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsAddFundingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsBankConnectionsAddFundingMutation, { data, loading, error }] = useRoundUpsBankConnectionsAddFundingMutation({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsAddFundingMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsBankConnectionsAddFundingMutation,
    RoundUpsBankConnectionsAddFundingMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    RoundUpsBankConnectionsAddFundingMutation,
    RoundUpsBankConnectionsAddFundingMutationVariables
  >(RoundUpsBankConnectionsAddFundingDocument, options)
}
export type RoundUpsBankConnectionsAddFundingMutationHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAddFundingMutation
>
export type RoundUpsBankConnectionsAddFundingMutationResult =
  Apollo.MutationResult<RoundUpsBankConnectionsAddFundingMutation>
export type RoundUpsBankConnectionsAddFundingMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsBankConnectionsAddFundingMutation,
  RoundUpsBankConnectionsAddFundingMutationVariables
>
export const RoundUpsBankConnectionsAddSubscriptionDocument = gql`
  mutation RoundUpsBankConnectionsAddSubscription($roundUpId: ID!, $accountIds: [ID!]!) {
    roundUpSubscribedAccountsAdd(input: { id: $roundUpId, accountIds: $accountIds }) {
      success
      record {
        id
      }
    }
  }
`
export type RoundUpsBankConnectionsAddSubscriptionMutationFn = Apollo.MutationFunction<
  RoundUpsBankConnectionsAddSubscriptionMutation,
  RoundUpsBankConnectionsAddSubscriptionMutationVariables
>

/**
 * __useRoundUpsBankConnectionsAddSubscriptionMutation__
 *
 * To run a mutation, you first call `useRoundUpsBankConnectionsAddSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsAddSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsBankConnectionsAddSubscriptionMutation, { data, loading, error }] = useRoundUpsBankConnectionsAddSubscriptionMutation({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      accountIds: // value for 'accountIds'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsAddSubscriptionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsBankConnectionsAddSubscriptionMutation,
    RoundUpsBankConnectionsAddSubscriptionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    RoundUpsBankConnectionsAddSubscriptionMutation,
    RoundUpsBankConnectionsAddSubscriptionMutationVariables
  >(RoundUpsBankConnectionsAddSubscriptionDocument, options)
}
export type RoundUpsBankConnectionsAddSubscriptionMutationHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAddSubscriptionMutation
>
export type RoundUpsBankConnectionsAddSubscriptionMutationResult =
  Apollo.MutationResult<RoundUpsBankConnectionsAddSubscriptionMutation>
export type RoundUpsBankConnectionsAddSubscriptionMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsBankConnectionsAddSubscriptionMutation,
  RoundUpsBankConnectionsAddSubscriptionMutationVariables
>
export const RoundUpsRecentActivityDocument = gql`
  query RoundUpsRecentActivity($roundUpId: ID!, $since: Date!) {
    roundUp(id: $roundUpId) {
      id
      recentActivity: balance(filter: { date_gte: $since }) {
        id
        current
      }
    }
  }
`

/**
 * __useRoundUpsRecentActivityQuery__
 *
 * To run a query within a React component, call `useRoundUpsRecentActivityQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsRecentActivityQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsRecentActivityQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      since: // value for 'since'
 *   },
 * });
 */
export function useRoundUpsRecentActivityQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsRecentActivityQuery,
    RoundUpsRecentActivityQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpsRecentActivityQuery, RoundUpsRecentActivityQueryVariables>(
    RoundUpsRecentActivityDocument,
    options
  )
}
export function useRoundUpsRecentActivityLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsRecentActivityQuery,
    RoundUpsRecentActivityQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<RoundUpsRecentActivityQuery, RoundUpsRecentActivityQueryVariables>(
    RoundUpsRecentActivityDocument,
    options
  )
}
export type RoundUpsRecentActivityQueryHookResult = ReturnType<
  typeof useRoundUpsRecentActivityQuery
>
export type RoundUpsRecentActivityLazyQueryHookResult = ReturnType<
  typeof useRoundUpsRecentActivityLazyQuery
>
export type RoundUpsRecentActivityQueryResult = Apollo.QueryResult<
  RoundUpsRecentActivityQuery,
  RoundUpsRecentActivityQueryVariables
>
export const RoundUpsBankConnectionsSummaryCardFooterDocument = gql`
  query RoundUpsBankConnectionsSummaryCardFooter($id: ID!) {
    roundUp(id: $id) {
      id
      fundingAccount {
        id
        balance {
          current
        }
      }
    }
  }
`

/**
 * __useRoundUpsBankConnectionsSummaryCardFooterQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsSummaryCardFooterQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsSummaryCardFooterQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsSummaryCardFooterQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsSummaryCardFooterQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsSummaryCardFooterQuery,
    RoundUpsBankConnectionsSummaryCardFooterQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsSummaryCardFooterQuery,
    RoundUpsBankConnectionsSummaryCardFooterQueryVariables
  >(RoundUpsBankConnectionsSummaryCardFooterDocument, options)
}
export function useRoundUpsBankConnectionsSummaryCardFooterLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsSummaryCardFooterQuery,
    RoundUpsBankConnectionsSummaryCardFooterQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsSummaryCardFooterQuery,
    RoundUpsBankConnectionsSummaryCardFooterQueryVariables
  >(RoundUpsBankConnectionsSummaryCardFooterDocument, options)
}
export type RoundUpsBankConnectionsSummaryCardFooterQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsSummaryCardFooterQuery
>
export type RoundUpsBankConnectionsSummaryCardFooterLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsSummaryCardFooterLazyQuery
>
export type RoundUpsBankConnectionsSummaryCardFooterQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsSummaryCardFooterQuery,
  RoundUpsBankConnectionsSummaryCardFooterQueryVariables
>
export const RoundUpsBankConnectionsSummaryCardHeaderDocument = gql`
  query RoundUpsBankConnectionsSummaryCardHeader {
    plaidItems {
      id
    }
  }
`

/**
 * __useRoundUpsBankConnectionsSummaryCardHeaderQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsSummaryCardHeaderQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsSummaryCardHeaderQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsSummaryCardHeaderQuery({
 *   variables: {
 *   },
 * });
 */
export function useRoundUpsBankConnectionsSummaryCardHeaderQuery(
  baseOptions?: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsSummaryCardHeaderQuery,
    RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsSummaryCardHeaderQuery,
    RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
  >(RoundUpsBankConnectionsSummaryCardHeaderDocument, options)
}
export function useRoundUpsBankConnectionsSummaryCardHeaderLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsSummaryCardHeaderQuery,
    RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsSummaryCardHeaderQuery,
    RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
  >(RoundUpsBankConnectionsSummaryCardHeaderDocument, options)
}
export type RoundUpsBankConnectionsSummaryCardHeaderQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsSummaryCardHeaderQuery
>
export type RoundUpsBankConnectionsSummaryCardHeaderLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsSummaryCardHeaderLazyQuery
>
export type RoundUpsBankConnectionsSummaryCardHeaderQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsSummaryCardHeaderQuery,
  RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
>
export const RoundUpsBankConnectionsCardDocument = gql`
  query RoundUpsBankConnectionsCard($roundUpId: ID!, $id: ID!) {
    roundUp(id: $roundUpId) {
      id
    }
    plaidItem(id: $id) {
      id
      name
      status
      syncedAt
      logo {
        url
      }
    }
  }
`

/**
 * __useRoundUpsBankConnectionsCardQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsCardQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsCardQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsCardQuery,
    RoundUpsBankConnectionsCardQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsCardQuery,
    RoundUpsBankConnectionsCardQueryVariables
  >(RoundUpsBankConnectionsCardDocument, options)
}
export function useRoundUpsBankConnectionsCardLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsCardQuery,
    RoundUpsBankConnectionsCardQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsCardQuery,
    RoundUpsBankConnectionsCardQueryVariables
  >(RoundUpsBankConnectionsCardDocument, options)
}
export type RoundUpsBankConnectionsCardQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsCardQuery
>
export type RoundUpsBankConnectionsCardLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsCardLazyQuery
>
export type RoundUpsBankConnectionsCardQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsCardQuery,
  RoundUpsBankConnectionsCardQueryVariables
>
export const RoundUpsBankConnectionsListDocument = gql`
  query RoundUpsBankConnectionsList($roundUpId: ID!) {
    roundUp(id: $roundUpId) {
      id
      fundingAccount {
        ...AccountFragment
        balance {
          current
        }
      }
    }
    plaidItems {
      id
      name
      status
      syncedAt
      logo {
        url
      }
      status
      syncedAt
    }
  }
  ${AccountFragmentFragmentDoc}
`

/**
 * __useRoundUpsBankConnectionsListQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsListQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsListQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsListQuery,
    RoundUpsBankConnectionsListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsListQuery,
    RoundUpsBankConnectionsListQueryVariables
  >(RoundUpsBankConnectionsListDocument, options)
}
export function useRoundUpsBankConnectionsListLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsListQuery,
    RoundUpsBankConnectionsListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsListQuery,
    RoundUpsBankConnectionsListQueryVariables
  >(RoundUpsBankConnectionsListDocument, options)
}
export type RoundUpsBankConnectionsListQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsListQuery
>
export type RoundUpsBankConnectionsListLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsListLazyQuery
>
export type RoundUpsBankConnectionsListQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsListQuery,
  RoundUpsBankConnectionsListQueryVariables
>
export const RoundUpsBankConnectionsListItemDocument = gql`
  query RoundUpsBankConnectionsListItem($roundUpId: ID!, $id: ID!) {
    roundUp(id: $roundUpId) {
      id
      fundingAccount {
        ...AccountFragment
        balance {
          current
        }
      }
    }
    plaidItem(id: $id) {
      id
      name
      status
      syncedAt
      logo {
        url
      }
      status
      syncedAt
    }
  }
  ${AccountFragmentFragmentDoc}
`

/**
 * __useRoundUpsBankConnectionsListItemQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsListItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsListItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsListItemQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsListItemQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsListItemQuery,
    RoundUpsBankConnectionsListItemQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsListItemQuery,
    RoundUpsBankConnectionsListItemQueryVariables
  >(RoundUpsBankConnectionsListItemDocument, options)
}
export function useRoundUpsBankConnectionsListItemLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsListItemQuery,
    RoundUpsBankConnectionsListItemQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsListItemQuery,
    RoundUpsBankConnectionsListItemQueryVariables
  >(RoundUpsBankConnectionsListItemDocument, options)
}
export type RoundUpsBankConnectionsListItemQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsListItemQuery
>
export type RoundUpsBankConnectionsListItemLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsListItemLazyQuery
>
export type RoundUpsBankConnectionsListItemQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsListItemQuery,
  RoundUpsBankConnectionsListItemQueryVariables
>
export const RoundUpsBankConnectionsPageDocument = gql`
  query RoundUpsBankConnectionsPage($id: ID!) {
    roundUp(id: $id) {
      id
      fundingAccount {
        id
        balance {
          current
        }
      }
    }
    plaidItems {
      id
      status
      syncedAt
      accounts {
        id
      }
    }
  }
`

/**
 * __useRoundUpsBankConnectionsPageQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsPageQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsPageQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsPageQuery,
    RoundUpsBankConnectionsPageQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsPageQuery,
    RoundUpsBankConnectionsPageQueryVariables
  >(RoundUpsBankConnectionsPageDocument, options)
}
export function useRoundUpsBankConnectionsPageLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsPageQuery,
    RoundUpsBankConnectionsPageQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsPageQuery,
    RoundUpsBankConnectionsPageQueryVariables
  >(RoundUpsBankConnectionsPageDocument, options)
}
export type RoundUpsBankConnectionsPageQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsPageQuery
>
export type RoundUpsBankConnectionsPageLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsPageLazyQuery
>
export type RoundUpsBankConnectionsPageQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsPageQuery,
  RoundUpsBankConnectionsPageQueryVariables
>
export const RoundUpsPauseDocument = gql`
  mutation RoundUpsPause($id: ID!) {
    roundUpPause(input: { id: $id }) {
      record {
        id
        status
      }
    }
  }
`
export type RoundUpsPauseMutationFn = Apollo.MutationFunction<
  RoundUpsPauseMutation,
  RoundUpsPauseMutationVariables
>

/**
 * __useRoundUpsPauseMutation__
 *
 * To run a mutation, you first call `useRoundUpsPauseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsPauseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsPauseMutation, { data, loading, error }] = useRoundUpsPauseMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsPauseMutation(
  baseOptions?: Apollo.MutationHookOptions<RoundUpsPauseMutation, RoundUpsPauseMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<RoundUpsPauseMutation, RoundUpsPauseMutationVariables>(
    RoundUpsPauseDocument,
    options
  )
}
export type RoundUpsPauseMutationHookResult = ReturnType<typeof useRoundUpsPauseMutation>
export type RoundUpsPauseMutationResult = Apollo.MutationResult<RoundUpsPauseMutation>
export type RoundUpsPauseMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsPauseMutation,
  RoundUpsPauseMutationVariables
>
export const RoundUpsResumeDocument = gql`
  mutation RoundUpsResume($id: ID!) {
    roundUpResume(input: { id: $id }) {
      record {
        id
        status
      }
    }
  }
`
export type RoundUpsResumeMutationFn = Apollo.MutationFunction<
  RoundUpsResumeMutation,
  RoundUpsResumeMutationVariables
>

/**
 * __useRoundUpsResumeMutation__
 *
 * To run a mutation, you first call `useRoundUpsResumeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsResumeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsResumeMutation, { data, loading, error }] = useRoundUpsResumeMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsResumeMutation(
  baseOptions?: Apollo.MutationHookOptions<RoundUpsResumeMutation, RoundUpsResumeMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<RoundUpsResumeMutation, RoundUpsResumeMutationVariables>(
    RoundUpsResumeDocument,
    options
  )
}
export type RoundUpsResumeMutationHookResult = ReturnType<typeof useRoundUpsResumeMutation>
export type RoundUpsResumeMutationResult = Apollo.MutationResult<RoundUpsResumeMutation>
export type RoundUpsResumeMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsResumeMutation,
  RoundUpsResumeMutationVariables
>
export const RoundUpSummaryDocument = gql`
  query RoundUpSummary($id: ID!, $startOfWeek: Date) {
    roundUp(id: $id) {
      id
      totalAmount: balance {
        id
        available
        current
      }
      thisWeek: balance(filter: { date_gte: $startOfWeek }) {
        id
        available
        current
      }
    }
  }
`

/**
 * __useRoundUpSummaryQuery__
 *
 * To run a query within a React component, call `useRoundUpSummaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpSummaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpSummaryQuery({
 *   variables: {
 *      id: // value for 'id'
 *      startOfWeek: // value for 'startOfWeek'
 *   },
 * });
 */
export function useRoundUpSummaryQuery(
  baseOptions: Apollo.QueryHookOptions<RoundUpSummaryQuery, RoundUpSummaryQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpSummaryQuery, RoundUpSummaryQueryVariables>(
    RoundUpSummaryDocument,
    options
  )
}
export function useRoundUpSummaryLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<RoundUpSummaryQuery, RoundUpSummaryQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<RoundUpSummaryQuery, RoundUpSummaryQueryVariables>(
    RoundUpSummaryDocument,
    options
  )
}
export type RoundUpSummaryQueryHookResult = ReturnType<typeof useRoundUpSummaryQuery>
export type RoundUpSummaryLazyQueryHookResult = ReturnType<typeof useRoundUpSummaryLazyQuery>
export type RoundUpSummaryQueryResult = Apollo.QueryResult<
  RoundUpSummaryQuery,
  RoundUpSummaryQueryVariables
>
export const RoundUpHistoryDocument = gql`
  query RoundUpHistory(
    $id: ID!
    $day0: Date!
    $day1: Date!
    $day2: Date!
    $day3: Date!
    $day4: Date!
    $day5: Date!
    $day6: Date!
  ) {
    roundUp(id: $id) {
      id
      day0: balance(filter: { date_gte: $day0 }) {
        id
        available
      }
      day1: balance(filter: { date_lt: $day0, date_gte: $day1 }) {
        id
        available
      }
      day2: balance(filter: { date_lt: $day1, date_gte: $day2 }) {
        id
        available
      }
      day3: balance(filter: { date_lt: $day2, date_gte: $day3 }) {
        id
        available
      }
      day4: balance(filter: { date_lt: $day3, date_gte: $day4 }) {
        id
        available
      }
      day5: balance(filter: { date_lt: $day4, date_gte: $day5 }) {
        id
        available
      }
      day6: balance(filter: { date_lt: $day5, date_gte: $day6 }) {
        id
        available
      }
    }
  }
`

/**
 * __useRoundUpHistoryQuery__
 *
 * To run a query within a React component, call `useRoundUpHistoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpHistoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpHistoryQuery({
 *   variables: {
 *      id: // value for 'id'
 *      day0: // value for 'day0'
 *      day1: // value for 'day1'
 *      day2: // value for 'day2'
 *      day3: // value for 'day3'
 *      day4: // value for 'day4'
 *      day5: // value for 'day5'
 *      day6: // value for 'day6'
 *   },
 * });
 */
export function useRoundUpHistoryQuery(
  baseOptions: Apollo.QueryHookOptions<RoundUpHistoryQuery, RoundUpHistoryQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpHistoryQuery, RoundUpHistoryQueryVariables>(
    RoundUpHistoryDocument,
    options
  )
}
export function useRoundUpHistoryLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<RoundUpHistoryQuery, RoundUpHistoryQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<RoundUpHistoryQuery, RoundUpHistoryQueryVariables>(
    RoundUpHistoryDocument,
    options
  )
}
export type RoundUpHistoryQueryHookResult = ReturnType<typeof useRoundUpHistoryQuery>
export type RoundUpHistoryLazyQueryHookResult = ReturnType<typeof useRoundUpHistoryLazyQuery>
export type RoundUpHistoryQueryResult = Apollo.QueryResult<
  RoundUpHistoryQuery,
  RoundUpHistoryQueryVariables
>
export const RoundUpTransactionsDocument = gql`
  query RoundUpTransactions($id: ID!) {
    roundUp(id: $id) {
      id
      transactionsConnection {
        edges {
          node {
            id
            date
            amount
            description
          }
        }
      }
    }
  }
`

/**
 * __useRoundUpTransactionsQuery__
 *
 * To run a query within a React component, call `useRoundUpTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpTransactionsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpTransactionsQuery(
  baseOptions: Apollo.QueryHookOptions<RoundUpTransactionsQuery, RoundUpTransactionsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpTransactionsQuery, RoundUpTransactionsQueryVariables>(
    RoundUpTransactionsDocument,
    options
  )
}
export function useRoundUpTransactionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpTransactionsQuery,
    RoundUpTransactionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<RoundUpTransactionsQuery, RoundUpTransactionsQueryVariables>(
    RoundUpTransactionsDocument,
    options
  )
}
export type RoundUpTransactionsQueryHookResult = ReturnType<typeof useRoundUpTransactionsQuery>
export type RoundUpTransactionsLazyQueryHookResult = ReturnType<
  typeof useRoundUpTransactionsLazyQuery
>
export type RoundUpTransactionsQueryResult = Apollo.QueryResult<
  RoundUpTransactionsQuery,
  RoundUpTransactionsQueryVariables
>
export const RoundUpsDocument = gql`
  query RoundUps {
    roundUps {
      id
    }
  }
`

/**
 * __useRoundUpsQuery__
 *
 * To run a query within a React component, call `useRoundUpsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsQuery({
 *   variables: {
 *   },
 * });
 */
export function useRoundUpsQuery(
  baseOptions?: Apollo.QueryHookOptions<RoundUpsQuery, RoundUpsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpsQuery, RoundUpsQueryVariables>(RoundUpsDocument, options)
}
export function useRoundUpsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<RoundUpsQuery, RoundUpsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<RoundUpsQuery, RoundUpsQueryVariables>(RoundUpsDocument, options)
}
export type RoundUpsQueryHookResult = ReturnType<typeof useRoundUpsQuery>
export type RoundUpsLazyQueryHookResult = ReturnType<typeof useRoundUpsLazyQuery>
export type RoundUpsQueryResult = Apollo.QueryResult<RoundUpsQuery, RoundUpsQueryVariables>
export const RoundUpHomeDocument = gql`
  query RoundUpHome($id: ID!) {
    roundUp(id: $id) {
      id
      status
      fundingAccount {
        id
        balance {
          current
        }
      }
    }
  }
`

/**
 * __useRoundUpHomeQuery__
 *
 * To run a query within a React component, call `useRoundUpHomeQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpHomeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpHomeQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpHomeQuery(
  baseOptions: Apollo.QueryHookOptions<RoundUpHomeQuery, RoundUpHomeQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpHomeQuery, RoundUpHomeQueryVariables>(RoundUpHomeDocument, options)
}
export function useRoundUpHomeLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<RoundUpHomeQuery, RoundUpHomeQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<RoundUpHomeQuery, RoundUpHomeQueryVariables>(
    RoundUpHomeDocument,
    options
  )
}
export type RoundUpHomeQueryHookResult = ReturnType<typeof useRoundUpHomeQuery>
export type RoundUpHomeLazyQueryHookResult = ReturnType<typeof useRoundUpHomeLazyQuery>
export type RoundUpHomeQueryResult = Apollo.QueryResult<RoundUpHomeQuery, RoundUpHomeQueryVariables>
export const CreateRoundUpDocument = gql`
  mutation CreateRoundUp {
    roundUpCreate(input: {}) {
      success
      record {
        id
        status
      }
    }
  }
`
export type CreateRoundUpMutationFn = Apollo.MutationFunction<
  CreateRoundUpMutation,
  CreateRoundUpMutationVariables
>

/**
 * __useCreateRoundUpMutation__
 *
 * To run a mutation, you first call `useCreateRoundUpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRoundUpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRoundUpMutation, { data, loading, error }] = useCreateRoundUpMutation({
 *   variables: {
 *   },
 * });
 */
export function useCreateRoundUpMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateRoundUpMutation, CreateRoundUpMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateRoundUpMutation, CreateRoundUpMutationVariables>(
    CreateRoundUpDocument,
    options
  )
}
export type CreateRoundUpMutationHookResult = ReturnType<typeof useCreateRoundUpMutation>
export type CreateRoundUpMutationResult = Apollo.MutationResult<CreateRoundUpMutation>
export type CreateRoundUpMutationOptions = Apollo.BaseMutationOptions<
  CreateRoundUpMutation,
  CreateRoundUpMutationVariables
>
export const ProfileDocument = gql`
  query Profile {
    profile {
      ...ProfileFragment
    }
  }
  ${ProfileFragmentFragmentDoc}
`

/**
 * __useProfileQuery__
 *
 * To run a query within a React component, call `useProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileQuery({
 *   variables: {
 *   },
 * });
 */
export function useProfileQuery(
  baseOptions?: Apollo.QueryHookOptions<ProfileQuery, ProfileQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<ProfileQuery, ProfileQueryVariables>(ProfileDocument, options)
}
export function useProfileLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<ProfileQuery, ProfileQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<ProfileQuery, ProfileQueryVariables>(ProfileDocument, options)
}
export type ProfileQueryHookResult = ReturnType<typeof useProfileQuery>
export type ProfileLazyQueryHookResult = ReturnType<typeof useProfileLazyQuery>
export type ProfileQueryResult = Apollo.QueryResult<ProfileQuery, ProfileQueryVariables>
export const ProfileUpdateDocument = gql`
  mutation ProfileUpdate($input: ProfileUpdateInput!) {
    profileUpdate(input: $input) {
      record {
        ...ProfileFragment
      }
      errors {
        path
        message
      }
    }
  }
  ${ProfileFragmentFragmentDoc}
`
export type ProfileUpdateMutationFn = Apollo.MutationFunction<
  ProfileUpdateMutation,
  ProfileUpdateMutationVariables
>

/**
 * __useProfileUpdateMutation__
 *
 * To run a mutation, you first call `useProfileUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProfileUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [profileUpdateMutation, { data, loading, error }] = useProfileUpdateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useProfileUpdateMutation(
  baseOptions?: Apollo.MutationHookOptions<ProfileUpdateMutation, ProfileUpdateMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<ProfileUpdateMutation, ProfileUpdateMutationVariables>(
    ProfileUpdateDocument,
    options
  )
}
export type ProfileUpdateMutationHookResult = ReturnType<typeof useProfileUpdateMutation>
export type ProfileUpdateMutationResult = Apollo.MutationResult<ProfileUpdateMutation>
export type ProfileUpdateMutationOptions = Apollo.BaseMutationOptions<
  ProfileUpdateMutation,
  ProfileUpdateMutationVariables
>
