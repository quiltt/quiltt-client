import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'

export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
const defaultOptions = {} as const
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** Represents an ISO 8601-encoded date */
  Date: any
  /** Represents an ISO 8601-encoded datetime */
  DateTime: any
  /** Represents untyped JSON */
  JSON: any
  /** A valid URL, transported as a string */
  URL: any
}

/** Represents an Account */
export type Account = {
  __typename?: 'Account'
  /** Balance */
  balance: LedgerBalance
  /** Primary Connection for this Account */
  connection?: Maybe<ConnectionType>
  /** ID */
  id: Scalars['ID']
  /** Last 4 numbers */
  lastFourDigits?: Maybe<Scalars['String']>
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
  /** Name */
  name: Scalars['String']
  /** @deprecated Use connection */
  plaidItem?: Maybe<PlaidItem>
  /** API Account Data Source */
  source?: Maybe<AccountSources>
  /** API Account Data Sources */
  sources?: Maybe<Array<AccountSources>>
  /** State */
  state: LedgerState
  /**
   * Status
   * @deprecated Use `state` instead.
   */
  status: LedgerStatus
  /** A limited list of transactions. Use `transactionsConnection` for a full paginated list. */
  transactions: Array<Transaction>
  /** Cursor-based pagination transactions */
  transactionsConnection: TransactionConnection
  /** Account type */
  type: AccountType
}

/** Represents an Account */
export type AccountSourceArgs = {
  type: AccountSourceType
}

/** Represents an Account */
export type AccountSourcesArgs = {
  types?: InputMaybe<Array<AccountSourceType>>
}

/** Represents an Account */
export type AccountTransactionsArgs = {
  filter?: InputMaybe<TransactionFilter>
  limit?: Scalars['Int']
  search?: InputMaybe<SearchQuery>
  sort?: InputMaybe<TransactionSort>
}

/** Represents an Account */
export type AccountTransactionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>
  before?: InputMaybe<Scalars['String']>
  filter?: InputMaybe<TransactionFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  search?: InputMaybe<SearchQuery>
  sort?: InputMaybe<TransactionSort>
}

/** Options for Filtering Accounts */
export type AccountFilter = {
  /** Account classification */
  type?: InputMaybe<Array<AccountType>>
}

/** Represents a data source for the Account */
export enum AccountSourceType {
  /** Mock connection */
  Mock = 'MOCK',
  /** MX connection */
  Mx = 'MX',
  /** Plaid connection */
  Plaid = 'PLAID',
}

export type AccountSources = MockAccount | PlaidAccount

/** Represents the classification of an Account */
export enum AccountType {
  /** Checking and cash management accounts */
  Checking = 'CHECKING',
  /** Credit card accounts */
  Credit = 'CREDIT',
  /** Brokerage, retirement and other retirement accounts */
  Investment = 'INVESTMENT',
  /** Lines of credit, mortgage, student and installment loans */
  Loan = 'LOAN',
  /** All other accounts */
  Other = 'OTHER',
  /** Savings and money market accounts */
  Savings = 'SAVINGS',
}

/** Autogenerated input type of AccountUpdate */
export type AccountUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['ID']
  /** Customizable metadata */
  metadata?: InputMaybe<Scalars['JSON']>
}

/** Autogenerated return type of AccountUpdate */
export type AccountUpdatePayload = {
  __typename?: 'AccountUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated Account Information */
  record?: Maybe<Account>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** ISO 3166-1 alpha-3 Country Codes */
export enum AddressCountryCode {
  /** United States of America */
  Usa = 'USA',
}

/** Represents a data source for the Connection */
export enum ConnectionSourceType {
  /** Mock connection */
  Mock = 'MOCK',
  /** MX connection */
  Mx = 'MX',
  /** Plaid connection */
  Plaid = 'PLAID',
}

export type ConnectionSources = MockConnection | MxConnection | PlaidConnection

/** Represents a Connection */
export type ConnectionType = {
  __typename?: 'ConnectionType'
  /** The list of accounts */
  accounts: Array<Account>
  /** Is this managed by an external system? */
  externallyManaged: Scalars['Boolean']
  /** ID */
  id: Scalars['ID']
  /** Institution */
  institution: Institution
  /** API Connection Data Source */
  source?: Maybe<ConnectionSources>
  /** API Connection Data Sources */
  sources?: Maybe<Array<ConnectionSources>>
}

/** Represents a Connection */
export type ConnectionTypeAccountsArgs = {
  filter?: InputMaybe<AccountFilter>
  search?: InputMaybe<SearchQuery>
}

/** Represents a Connection */
export type ConnectionTypeSourceArgs = {
  type: ConnectionSourceType
}

/** Represents a Connection */
export type ConnectionTypeSourcesArgs = {
  types?: InputMaybe<Array<ConnectionSourceType>>
}

/** Represents an Error */
export type Error = {
  __typename?: 'Error'
  /** Error Message */
  message?: Maybe<Scalars['String']>
  /** Object path for error */
  path?: Maybe<Array<Scalars['String']>>
}

/** Represents an image */
export type Image = {
  __typename?: 'Image'
  /** URL for the image */
  url?: Maybe<Scalars['URL']>
}

/** Represents an Institution */
export type Institution = {
  __typename?: 'Institution'
  /** Name */
  name: Scalars['String']
}

export type LedgerBalance = {
  __typename?: 'LedgerBalance'
  /** The amount of funds including pending transactions */
  available?: Maybe<Scalars['Float']>
  /** The amount of funds based on posted transactions */
  current?: Maybe<Scalars['Float']>
  /** Cache Key */
  id: Scalars['ID']
  /** The amount of funds that may be overdraft or spent on credit */
  limit?: Maybe<Scalars['Float']>
}

export enum LedgerState {
  /** Terminated */
  Closed = 'CLOSED',
  /** Open */
  Open = 'OPEN',
  /** Disabled */
  Paused = 'PAUSED',
}

export enum LedgerStatus {
  /** Active */
  Active = 'ACTIVE',
  /** Terminated */
  Closed = 'CLOSED',
  /** Duplicate or disabled */
  Hidden = 'HIDDEN',
  /** Automation disabled */
  Paused = 'PAUSED',
}

/** Represents a Merchant */
export type Merchant = {
  __typename?: 'Merchant'
  /** ID */
  id: Scalars['ID']
  /** Name */
  name: Scalars['String']
  /** API Merchant Data Source */
  source?: Maybe<MerchantSources>
  /** API Merchant Data Sources */
  sources?: Maybe<Array<MerchantSources>>
  /** State */
  state: LedgerState
  /**
   * Status
   * @deprecated Use `state` instead.
   */
  status: LedgerStatus
  /** A limited list of transactions. Use `transactionsConnection` for a full paginated list. */
  transactions: Array<Transaction>
  /** Cursor-based pagination transactions */
  transactionsConnection: TransactionConnection
}

/** Represents a Merchant */
export type MerchantSourceArgs = {
  type: MerchantSourceType
}

/** Represents a Merchant */
export type MerchantSourcesArgs = {
  types?: InputMaybe<Array<MerchantSourceType>>
}

/** Represents a Merchant */
export type MerchantTransactionsArgs = {
  filter?: InputMaybe<TransactionFilter>
  limit?: Scalars['Int']
  search?: InputMaybe<SearchQuery>
  sort?: InputMaybe<TransactionSort>
}

/** Represents a Merchant */
export type MerchantTransactionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>
  before?: InputMaybe<Scalars['String']>
  filter?: InputMaybe<TransactionFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  search?: InputMaybe<SearchQuery>
  sort?: InputMaybe<TransactionSort>
}

/** Represents a data source for the Merchant */
export enum MerchantSourceType {
  /** Plaid Transaction Data */
  Plaid = 'PLAID',
  /** Spade Transaction Enrichment */
  Spade = 'SPADE',
}

export type MerchantSources = PlaidMerchant | SpadeMerchant

/** Mock Account Data */
export type MockAccount = {
  __typename?: 'MockAccount'
  /** API Source */
  _sourcename: AccountSourceType
}

/** Mock Connection Data */
export type MockConnection = {
  __typename?: 'MockConnection'
  /** API Source */
  _sourcename: ConnectionSourceType
}

/** Mock Transaction Data */
export type MockTransaction = {
  __typename?: 'MockTransaction'
  /** API Source */
  _sourcename: TransactionSourceType
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type Mutation = {
  __typename?: 'Mutation'
  /** Update Account Information */
  accountUpdate?: Maybe<AccountUpdatePayload>
  /**
   * Create a Plaid Item from a successful Link submission
   * @deprecated Use connection_plaid_create
   */
  plaidItemCreate?: Maybe<PlaidItemCreatePayload>
  /**
   * Delete a Plaid Item
   * @deprecated Use connection_delete
   */
  plaidItemDelete?: Maybe<PlaidItemDeletePayload>
  /**
   * Import a Plaid Item with a valid access token
   * @deprecated Use connection_plaid_import
   */
  plaidItemImport?: Maybe<PlaidItemImportPayload>
  /**
   * Create a Link Token to configure an instance of Link
   * @deprecated Use connector_plaid_initialize
   */
  plaidLinkTokenCreate?: Maybe<PlaidLinkTokenCreatePayload>
  /**
   * Create a Link Token to configure an instance of Link in update mode
   * @deprecated Use connector_plaid_initialize
   */
  plaidLinkTokenCreateForUpdate?: Maybe<PlaidLinkTokenCreateForUpdatePayload>
  /** Create a Plaid Processor Token suitable for sending to one of Plaid's integration partners */
  plaidProcessorTokenCreate?: Maybe<PlaidProcessorTokenCreatePayload>
  /** Update Profile Information */
  profileUpdate?: Maybe<ProfileUpdatePayload>
  /** Create a RoundUp */
  roundUpCreate?: Maybe<RoundUpCreatePayload>
  /** Pause a RoundUp */
  roundUpPause?: Maybe<RoundUpPausePayload>
  /** Resume a RoundUp */
  roundUpResume?: Maybe<RoundUpResumePayload>
  /** Set the funding account for a RoundUp */
  roundUpSetFundingAccount?: Maybe<RoundUpSetFundingAccountPayload>
  /** Set the RoundUp start time */
  roundUpSetStartTime?: Maybe<RoundUpSetStartTimePayload>
  /** Add Accounts to a RoundUp */
  roundUpSubscribedAccountsAdd?: Maybe<RoundUpSubscribedAccountsAddPayload>
  /** Remove Accounts from a RoundUp */
  roundUpSubscribedAccountsRemove?: Maybe<RoundUpSubscribedAccountsRemovePayload>
  /** Update Transaction Information */
  transactionUpdate?: Maybe<TransactionUpdatePayload>
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationAccountUpdateArgs = {
  input: AccountUpdateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidItemCreateArgs = {
  input: PlaidItemCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidItemDeleteArgs = {
  input: PlaidItemDeleteInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidItemImportArgs = {
  input: PlaidItemImportInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidLinkTokenCreateArgs = {
  input: PlaidLinkTokenCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidLinkTokenCreateForUpdateArgs = {
  input: PlaidLinkTokenCreateForUpdateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidProcessorTokenCreateArgs = {
  input: PlaidProcessorTokenCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationProfileUpdateArgs = {
  input: ProfileUpdateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpCreateArgs = {
  input: RoundUpCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpPauseArgs = {
  input: RoundUpPauseInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpResumeArgs = {
  input: RoundUpResumeInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpSetFundingAccountArgs = {
  input: RoundUpSetFundingAccountInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpSetStartTimeArgs = {
  input: RoundUpSetStartTimeInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpSubscribedAccountsAddArgs = {
  input: RoundUpSubscribedAccountsAddInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpSubscribedAccountsRemoveArgs = {
  input: RoundUpSubscribedAccountsRemoveInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationTransactionUpdateArgs = {
  input: TransactionUpdateInput
}

/** MX Member Data */
export type MxConnection = {
  __typename?: 'MxConnection'
  /** API Source */
  _sourcename: ConnectionSourceType
  /**
   * The date and time the most recent aggregation-type job was started, given in
   * ISO 8601 format with a time component. A job will automatically be started
   * when a member is created or its credentials are updated, unless the
   * skip_aggregation parameter is used. Jobs can also be started via manual
   * aggregations, background aggregations, API endpoints, or when opening an MX
   * widget. A job can be a normal aggregation, or a premium job such as
   * identification, verification, fetching statements, or fetching an extended
   * transaction history.
   */
  aggregatedAt?: Maybe<Scalars['String']>
  /** This indicates the state of a member’s aggregation. See member connection statuses for more information. */
  connectionStatus?: Maybe<Scalars['String']>
  /** The unique identifier for the member. Defined by MX. */
  guid?: Maybe<Scalars['String']>
  /** The partner-defined unique identifier for the member. */
  id?: Maybe<Scalars['String']>
  /** The unique identifier for the institution associated with the member. Defined by MX. */
  institutionCode?: Maybe<Scalars['String']>
  /** This indicates whether the member was being aggregated at the time of the request. */
  isBeingAggregated?: Maybe<Scalars['Boolean']>
  /**
   * This indicates whether the member is managed by the user or the MX partner.
   * Members created with the managed member feature will have this field set to false.
   */
  isManagedByUser?: Maybe<Scalars['Boolean']>
  /** This indicates whether the member uses OAuth to authenticate. Defaults to false. */
  isOauth?: Maybe<Scalars['Boolean']>
  /** Additional information you can store on this member. */
  metadata?: Maybe<Scalars['String']>
  /** The name of the member. */
  name?: Maybe<Scalars['String']>
  oauthWindowUri?: Maybe<Scalars['String']>
  /** The date and time the member was last successfully aggregated. */
  successfullyAggregatedAt?: Maybe<Scalars['String']>
  /** The unique identifier for the user associated with the member. Defined by MX. */
  userGuid?: Maybe<Scalars['String']>
  /** The unique partner-defined identifier for the user associated with the member. */
  userId?: Maybe<Scalars['String']>
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo'
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>
}

/** Represents a Plaid API Error */
export type PlaidApiError = {
  __typename?: 'PlaidAPIError'
  /** The particular error code. Safe for programmatic use. */
  code: Scalars['String']
  /** A user-friendly representation of the error code */
  displayMessage?: Maybe<Scalars['String']>
  /** A developer-friendly representation of the error code */
  message: Scalars['String']
  /** A unique ID identifying the request, to be used for troubleshooting purposes */
  requestId?: Maybe<Scalars['String']>
  /** A broad categorization of the error. Safe for programatic use. */
  type: Scalars['String']
}

/** Interest rates */
export type PlaidApr = {
  __typename?: 'PlaidAPR'
  /** Annual Percentage Rate applied. */
  aprPercentage: Scalars['Float']
  /** The type of balance to which the APR applies. Possible values: balance_transfer_apr, cash_apr, purchase_apr, special */
  aprType: Scalars['String']
  /**
   * Amount of money that is subjected to the APR if a balance was carried beyond
   * payment due date. How it is calculated can vary by card issuer. It is often
   * calculated as an average daily balance.
   */
  balanceSubjectToApr?: Maybe<Scalars['Float']>
  /** Amount of money charged due to interest from last statement. */
  interestChargeAmount?: Maybe<Scalars['Float']>
}

/** Plaid Account Data */
export type PlaidAccount = {
  __typename?: 'PlaidAccount'
  /** API Source */
  _sourcename: AccountSourceType
  /** Plaid’s unique identifier for the account */
  accountId: Scalars['String']
  /** A set of fields describing the balance for an account. Balance information may be cached */
  balances: PlaidAccountBalance
  /** The liabilities account details */
  liabilities?: Maybe<PlaidAccountLiabilities>
  /**
   * The last 2-4 alphanumeric characters of an account's official account number.
   * Note that the mask may be non-unique between an Item's accounts, and it may
   * also not match the mask that the bank displays to the user.
   */
  mask?: Maybe<Scalars['String']>
  /** The name of the account, either assigned by the user or by the financial institution itself */
  name: Scalars['String']
  /** The official name of the account as given by the financial institution */
  officialName?: Maybe<Scalars['String']>
  /**
   * Possible values: 401a, 401k, 403B, 457b, 529, brokerage, cash isa, education
   * savings account, gic, health reimbursement arrangement, hsa, isa, ira, lif,
   * lira, lrif, lrsp, non-taxable brokerage account, other, prif, rdsp, resp,
   * rlif, rrif, pension, profit sharing plan, retirement, roth, roth 401k, rrsp,
   * sep ira, simple ira, sipp, stock plan, thrift savings plan, tfsa, trust, ugma,
   * utma, variable annuity, credit card, paypal, cd, checking, savings, money
   * market, prepaid, auto, commercial, construction, consumer, home, home equity,
   * loan, mortgage, overdraft, line of credit, student, cash management, keogh,
   * mutual fund, recurring, rewards, safe deposit, sarsep, null
   */
  subtype?: Maybe<Scalars['String']>
  /** Possible values: investment, credit, depository, loan, brokerage, other */
  type: Scalars['String']
  /**
   * The current verification status of an Auth Item initiated through Automated or
   * Manual micro-deposits.  Returned for Auth Items only.
   * Possible values: pending_automatic_verification, pending_manual_verification,
   * manually_verified, verification_expired, verification_failed
   */
  verificationStatus: Scalars['String']
}

/** A set of fields describing the balance for an account. */
export type PlaidAccountBalance = {
  __typename?: 'PlaidAccountBalance'
  /** The amount of funds available to be withdrawn from the account, as determined by the financial institution. */
  available?: Maybe<Scalars['Float']>
  /** The total amount of funds in or owed by the account. */
  current?: Maybe<Scalars['Float']>
  /** The ISO-4217 currency code of the balance. Always null if unofficial_currency_code is non-null. */
  isoCurrencyCode?: Maybe<Scalars['String']>
  /** The last time that the balance for the given account has been updated */
  lastUpdatedDatetime?: Maybe<Scalars['DateTime']>
  /** For credit-type accounts, this represents the credit limit. */
  limit?: Maybe<Scalars['Float']>
  /**
   * The unofficial currency code associated with the balance. Always null if
   * iso_currency_code is non-null. Unofficial currency codes are used for
   * currencies that do not have official ISO currency codes, such as
   * cryptocurrencies and the currencies of certain countries.
   */
  unofficialCurrencyCode?: Maybe<Scalars['String']>
}

/** Plaid Liabilities Data */
export type PlaidAccountLiabilities = {
  __typename?: 'PlaidAccountLiabilities'
  /** The credit card account details */
  credit?: Maybe<PlaidAccountLiabilitiesCredit>
  /** The mortgage account details */
  mortgage?: Maybe<PlaidAccountLiabilitiesMortgage>
  /** The student loan account details */
  student?: Maybe<PlaidAccountLiabilitiesStudent>
}

/** Plaid Credit Card Data */
export type PlaidAccountLiabilitiesCredit = {
  __typename?: 'PlaidAccountLiabilitiesCredit'
  /** Plaid’s unique identifier for the account */
  accountId?: Maybe<Scalars['String']>
  /** The various interest rates that apply to the account. */
  aprs: Array<PlaidApr>
  /** true if a payment is currently overdue. Availability for this field is limited. */
  isOverdue?: Maybe<Scalars['Boolean']>
  /** The amount of the last payment. */
  lastPaymentAmount: Scalars['Float']
  /** The date of the last payment. */
  lastPaymentDate?: Maybe<Scalars['Date']>
  /** The total amount owed as of the last statement issued */
  lastStatementBalance: Scalars['Float']
  /** The date of the last statement. */
  lastStatementIssueDate: Scalars['Date']
  /**
   * The minimum payment due for the next billing cycle. There are some exceptions:
   * Some institutions require a minimum payment across all loans associated with
   * an account number. Our API presents that same minimum payment amount on each
   * loan. The institutions that do this are: Great Lakes (ins_116861), Firstmark
   * (ins_116295), Commonbond Firstmark Services (ins_116950), Nelnet (ins_116528),
   * EdFinancial Services (ins_116304), Granite State (ins_116308), and Oklahoma
   * Student Loan Authority (ins_116945).
   * Firstmark (ins_116295) will display as $0 if there is an autopay program in effect.
   */
  minimumPaymentAmount: Scalars['Float']
  /** The due date for the next payment. */
  nextPaymentDueDate?: Maybe<Scalars['Date']>
}

/** Plaid Mortgage Data */
export type PlaidAccountLiabilitiesMortgage = {
  __typename?: 'PlaidAccountLiabilitiesMortgage'
  /** Plaid’s unique identifier for the account */
  accountId: Scalars['String']
  /**
   * The account number of the loan. For some institutions, this may be a masked
   * version of the number (e.g., the last 4 digits instead of the entire number).
   */
  accountNumber: Scalars['String']
  /** The current outstanding amount charged for late payment. */
  currentLateFee?: Maybe<Scalars['Float']>
  /** Total amount held in escrow to pay taxes and insurance on behalf of the borrower. */
  escrowBalance?: Maybe<Scalars['Float']>
  /** Indicates whether the borrower has private mortgage insurance in effect. */
  hasPmi?: Maybe<Scalars['Boolean']>
  /** Indicates whether the borrower will pay a penalty for early payoff of mortgage. */
  hasPrepaymentPenalty?: Maybe<Scalars['Boolean']>
  /** Object containing metadata about the interest rate for the mortgage. */
  interestRate: PlaidMortgageInterestRate
  /** The amount of the last payment. */
  lastPaymentAmount?: Maybe<Scalars['Float']>
  /** The date of the last payment. */
  lastPaymentDate?: Maybe<Scalars['Date']>
  /** Full duration of mortgage as at origination (e.g. 10 year). */
  loanTerm?: Maybe<Scalars['String']>
  /**
   * Description of the type of loan, for example conventional, fixed, or variable.
   * This field is provided directly from the loan servicer and does not have an
   * enumerated set of possible values.
   */
  loanTypeDescription?: Maybe<Scalars['String']>
  /** Original date on which mortgage is due in full. */
  maturityDate?: Maybe<Scalars['Date']>
  /** The amount of the next payment. */
  nextMonthlyPayment?: Maybe<Scalars['Float']>
  /** The due date for the next payment. */
  nextPaymentDueDate?: Maybe<Scalars['Date']>
  /** The date on which the loan was initially lent. */
  originationDate?: Maybe<Scalars['Date']>
  /** The original principal balance of the mortgage. */
  originationPrincipalAmount?: Maybe<Scalars['Float']>
  /** Amount of loan (principal + interest) past due for payment. */
  pastDueAmount?: Maybe<Scalars['Float']>
  /** Object containing fields describing property address. */
  propertyAddress: PlaidMortgagePropertyAddress
  /** The year to date (YTD) interest paid. Availability for this field is limited. */
  ytdInterestPaid?: Maybe<Scalars['Float']>
  /** The year to date (YTD) principal paid. Availability for this field is limited. */
  ytdPrincipalPaid?: Maybe<Scalars['Float']>
}

/** Plaid Studen Loan Data */
export type PlaidAccountLiabilitiesStudent = {
  __typename?: 'PlaidAccountLiabilitiesStudent'
  /** Plaid’s unique identifier for the account */
  accountId?: Maybe<Scalars['String']>
  /**
   * The account number of the loan. For some institutions, this may be a masked
   * version of the number (e.g., the last 4 digits instead of the entire number).
   */
  accountNumber?: Maybe<Scalars['String']>
  /** The dates on which loaned funds were disbursed or will be disbursed. These are often in the past. */
  disbursementDates?: Maybe<Array<Scalars['Date']>>
  /** The date when the student loan is expected to be paid off. Availability for this field is limited. */
  expectedPayoffDate?: Maybe<Scalars['Date']>
  /** The guarantor of the student loan. */
  guarantor?: Maybe<Scalars['String']>
  /** The interest rate on the loan as a percentage. */
  interestRatePercentage: Scalars['Float']
  /** true if a payment is currently overdue. Availability for this field is limited. */
  isOverdue?: Maybe<Scalars['Boolean']>
  /** The amount of the last payment. */
  lastPaymentAmount?: Maybe<Scalars['Float']>
  /** The date of the last payment. */
  lastPaymentDate?: Maybe<Scalars['Date']>
  /** The date of the last statement. */
  lastStatementIssueDate?: Maybe<Scalars['Date']>
  /** The type of loan, e.g., "Consolidation Loans". */
  loanName?: Maybe<Scalars['String']>
  /** An object representing the status of the student loan */
  loanStatus: PlaidStudentLoanStatus
  /**
   * The minimum payment due for the next billing cycle. There are some exceptions:
   * Some institutions require a minimum payment across all loans associated with
   * an account number. Our API presents that same minimum payment amount on each
   * loan. The institutions that do this are: Great Lakes (ins_116861), Firstmark
   * (ins_116295), Commonbond Firstmark Services (ins_116950), Nelnet (ins_116528),
   * EdFinancial Services (ins_116304), Granite State (ins_116308), and Oklahoma
   * Student Loan Authority (ins_116945).
   * Firstmark (ins_116295) will display as $0 if there is an autopay program in effect.
   */
  minimumPaymentAmount?: Maybe<Scalars['Float']>
  /** The due date for the next payment. */
  nextPaymentDueDate?: Maybe<Scalars['Date']>
  /** The date on which the loan was initially lent. */
  originationDate?: Maybe<Scalars['Date']>
  /** The original principal balance of the mortgage. */
  originationPrincipalAmount?: Maybe<Scalars['Float']>
  /**
   * The total dollar amount of the accrued interest balance. For Sallie Mae (
   * ins_116944), this amount is included in the current balance of the loan, so
   * this field will return as null.
   */
  outstandingInterestAmount?: Maybe<Scalars['Float']>
  /**
   * The relevant account number that should be used to reference this loan for
   * payments. In the majority of cases, payment_reference_number will match
   * account_number, but in some institutions, such as Great Lakes (ins_116861), it
   * will be different.
   */
  paymentReferenceNumber?: Maybe<Scalars['String']>
  /**
   * Information about the student's eligibility in the Public Service Loan
   * Forgiveness program. This is only returned if the institution is Fedloan (ins_116527).
   */
  pslfStatus: PlaidPslfStatus
  /** An object representing the repayment plan for the student loan */
  repaymentPlan: PlaidStudentRepaymentPlan
  /** The sequence number of the student loan. Heartland ECSI (ins_116948) does not make this field available. */
  sequenceNumber?: Maybe<Scalars['String']>
  /** The address of the student loan servicer. This is generally the remittance address to which payments should be sent. */
  servicerAddress: PlaidServicerAddressData
  /** The year to date (YTD) interest paid. Availability for this field is limited. */
  ytdInterestPaid?: Maybe<Scalars['Float']>
  /** The year to date (YTD) principal paid. Availability for this field is limited. */
  ytdPrincipalPaid?: Maybe<Scalars['Float']>
}

/** Plaid Item Data */
export type PlaidConnection = {
  __typename?: 'PlaidConnection'
  /** API Source */
  _sourcename: ConnectionSourceType
  /** A list of products available for the Item that have not yet been accessed. */
  availableProducts: Array<Scalars['String']>
  /**
   * A list of products that have been billed for the Item. Note -
   * `billed_products` is populated in all environments but only requests in
   * Production are billed.
   */
  billedProducts: Array<Scalars['String']>
  /**
   * The RFC 3339 timestamp after which the consent provided by the end user will
   * expire. Upon consent expiration, the item will enter the `ITEM_LOGIN_REQUIRED`
   * error state. To circumvent the `ITEM_LOGIN_REQUIRED` error and maintain
   * continuous consent, the end user can reauthenticate via Link’s update mode in
   * advance of the consent expiration time.  Note - This is only relevant for
   * certain OAuth-based institutions. For all other institutions, this field will be null.
   */
  consentExpirationTime?: Maybe<Scalars['DateTime']>
  error?: Maybe<PlaidError>
  /** The Plaid Institution ID associated with the Item. Field is `null` for Items created via Same Day Micro-deposits. */
  institutionId?: Maybe<Scalars['String']>
  /**
   * The Plaid Item ID. The `item_id` is always unique; linking the same account at
   * the same institution twice will result in two Items with different `item_id`
   * values. Like all Plaid identifiers, the `item_id` is case-sensitive.
   */
  itemId: Scalars['String']
  /** A list of authorized products for the Item. */
  products: Array<Scalars['String']>
  /**
   * Indicates whether an Item requires user interaction to be updated, which can
   * be the case for Items with some forms of two-factor authentication.
   * `background` - Item can be updated in the background  `user_present_required`
   * - Item requires user interaction to be updated
   */
  updateType: Scalars['String']
  /** The URL registered to receive webhooks for the Item. */
  webhook?: Maybe<Scalars['String']>
}

/**
 * We use standard HTTP response codes for success and failure notifications, and
 * our errors are further classified by error_type. In general, 200 HTTP codes
 * correspond to success, 40X codes are for developer- or user-related failures,
 * and 50X codes are for Plaid-related issues.  Error fields will be null if no
 * error has occurred.
 */
export type PlaidError = {
  __typename?: 'PlaidError'
  /**
   * In the Assets product, a request can pertain to more than one Item. If an
   * error is returned for such a request, `causes` will return an array of errors
   * containing a breakdown of these errors on the individual Item level, if any
   * can be identified.  `causes` will only be provided for the `error_type`
   * `ASSET_REPORT_ERROR`. `causes` will also not be populated inside an error
   * nested within a `warning` object.
   */
  causes: Array<Scalars['String']>
  /**
   * A user-friendly representation of the error code. `null` if the error is not
   * related to user action.  This may change over time and is not safe for
   * programmatic use.
   */
  displayMessage?: Maybe<Scalars['String']>
  /** The URL of a Plaid documentation page with more information about the error */
  documentationUrl: Scalars['String']
  /** The particular error code. Safe for programmatic use. */
  errorCode: Scalars['String']
  /** A developer-friendly representation of the error code. This may change over time and is not safe for programmatic use. */
  errorMessage: Scalars['String']
  /** A broad categorization of the error. Safe for programatic use. */
  errorType: Scalars['String']
  /**
   * A unique ID identifying the request, to be used for troubleshooting purposes.
   * This field will be omitted in errors provided by webhooks.
   */
  requestId: Scalars['String']
  /**
   * The HTTP status code associated with the error. This will only be returned in
   * the response body when the error information is provided via a webhook.
   */
  status?: Maybe<Scalars['Float']>
  /** Suggested steps for resolving the error */
  suggestedAction: Scalars['String']
}

/** Represents a Plaid Item */
export type PlaidItem = {
  __typename?: 'PlaidItem'
  /** Accounts */
  accounts: Array<Account>
  /** Number of accounts */
  accountsCount: Scalars['Int']
  /** Is this Plaid Item managed by an external system? */
  externallyManaged: Scalars['Boolean']
  /** Plaid Item ID */
  id: Scalars['ID']
  /** Institution logo */
  logo?: Maybe<Image>
  /** Name of the Plaid Item */
  name: Scalars['String']
  /** Item status */
  status: PlaidItemStatus
  /** Last sync time */
  syncedAt?: Maybe<Scalars['DateTime']>
}

/** Represents a Plaid Item */
export type PlaidItemAccountsArgs = {
  filter?: InputMaybe<AccountFilter>
  search?: InputMaybe<SearchQuery>
}

/** Autogenerated input type of PlaidItemCreate */
export type PlaidItemCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The `metadata` object from Plaid Link's `onSuccess` callback */
  metadata: Scalars['JSON']
  /** The `public_token` string from Plaid Link's `onSuccess` callback */
  publicToken: Scalars['String']
}

/** Autogenerated return type of PlaidItemCreate */
export type PlaidItemCreatePayload = {
  __typename?: 'PlaidItemCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Plaid Item */
  record?: Maybe<PlaidItem>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of PlaidItemDelete */
export type PlaidItemDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** ID of Plaid Item to delete */
  id: Scalars['ID']
}

/** Autogenerated return type of PlaidItemDelete */
export type PlaidItemDeletePayload = {
  __typename?: 'PlaidItemDeletePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Plaid Item */
  record?: Maybe<PlaidItem>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of PlaidItemImport */
export type PlaidItemImportInput = {
  /** The `access_token` for the item */
  accessToken: Scalars['String']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** Whether the Plaid Item is managed by an external system */
  externallyManaged?: InputMaybe<Scalars['Boolean']>
}

/** Autogenerated return type of PlaidItemImport */
export type PlaidItemImportPayload = {
  __typename?: 'PlaidItemImportPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Plaid Item */
  record?: Maybe<PlaidItem>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Represents the sync status of a Plaid Item */
export enum PlaidItemStatus {
  /** Needs reconnecting */
  Disconnected = 'DISCONNECTED',
  /** In an error state */
  Error = 'ERROR',
  /** Successfully synced */
  Synced = 'SYNCED',
  /** Currently syncing */
  Syncing = 'SYNCING',
}

/** Autogenerated return type of PlaidItemUpdated */
export type PlaidItemUpdatedPayload = {
  __typename?: 'PlaidItemUpdatedPayload'
  record?: Maybe<PlaidItem>
}

export type PlaidLinkAccountFiltersCreditAccountSubtypesInput = {
  accountSubtypes: Array<Scalars['String']>
}

export type PlaidLinkAccountFiltersDepositoryAccountSubtypesInput = {
  accountSubtypes: Array<Scalars['String']>
}

export type PlaidLinkAccountFiltersInput = {
  credit?: InputMaybe<PlaidLinkAccountFiltersCreditAccountSubtypesInput>
  depository?: InputMaybe<PlaidLinkAccountFiltersDepositoryAccountSubtypesInput>
}

/** Represents a Link Token */
export type PlaidLinkToken = {
  __typename?: 'PlaidLinkToken'
  /** Expiration time of the `link_token` */
  expiration: Scalars['DateTime']
  /** A `link_token` that can be supplied to initialize Plaid Link */
  linkToken: Scalars['ID']
}

/** Autogenerated input type of PlaidLinkTokenCreateForUpdate */
export type PlaidLinkTokenCreateForUpdateInput = {
  /**
   * The name of your app's Android package. Required if using the link_token to
   * initialize Link on Android. When creating a link_token for initializing Link
   * on other platforms, this field must be left blank. Any package name specified
   * here must also be added to the Allowed Android package names setting on the
   * developer dashboard.
   */
  androidPackageName?: InputMaybe<Scalars['String']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** An array of Plaid-supported country codes using ISO-3166-1 alpha-2 country code standard */
  countryCodes?: InputMaybe<Array<Scalars['String']>>
  /** The language that Link should be displayed in. Defaults to your Quiltt app's language */
  language?: InputMaybe<Scalars['String']>
  /** The name of the Link customization from the Plaid Dashboard to be applied to Link */
  linkCustomizationName?: InputMaybe<Scalars['String']>
  /** The ID of the Plaid Item to update */
  plaidItemId: Scalars['ID']
}

/** Autogenerated return type of PlaidLinkTokenCreateForUpdate */
export type PlaidLinkTokenCreateForUpdatePayload = {
  __typename?: 'PlaidLinkTokenCreateForUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Link Token */
  record?: Maybe<PlaidLinkToken>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of PlaidLinkTokenCreate */
export type PlaidLinkTokenCreateInput = {
  accountFilters?: InputMaybe<PlaidLinkAccountFiltersInput>
  /**
   * The name of your app's Android package. Required if using the link_token to
   * initialize Link on Android. When creating a link_token for initializing Link
   * on other platforms, this field must be left blank. Any package name specified
   * here must also be added to the Allowed Android package names setting on the
   * developer dashboard.
   */
  androidPackageName?: InputMaybe<Scalars['String']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** An array of Plaid-supported country codes using ISO-3166-1 alpha-2 country code standard */
  countryCodes?: InputMaybe<Array<Scalars['String']>>
  /** The language that Link should be displayed in. Defaults to your Quiltt app's language */
  language?: InputMaybe<Scalars['String']>
  /** The name of the Link customization from the Plaid Dashboard to be applied to Link */
  linkCustomizationName?: InputMaybe<Scalars['String']>
  /** List of products to use with Link */
  products: Array<Scalars['String']>
}

/** Autogenerated return type of PlaidLinkTokenCreate */
export type PlaidLinkTokenCreatePayload = {
  __typename?: 'PlaidLinkTokenCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Link Token */
  record?: Maybe<PlaidLinkToken>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** A representation of where */
export type PlaidLocation = {
  __typename?: 'PlaidLocation'
  /** The street address */
  address?: Maybe<Scalars['String']>
  /** The city */
  city?: Maybe<Scalars['String']>
  /** The ISO 3166-1 alpha-2 country code */
  country?: Maybe<Scalars['String']>
  /** The latitude */
  lat?: Maybe<Scalars['Float']>
  /** The longitude */
  lon?: Maybe<Scalars['Float']>
  /** The postal code */
  postalCode?: Maybe<Scalars['String']>
  /** The region or state */
  region?: Maybe<Scalars['String']>
  /** The merchant defined store number */
  storeNumber?: Maybe<Scalars['String']>
}

/** Plaid Merchant Data */
export type PlaidMerchant = {
  __typename?: 'PlaidMerchant'
  /** API Source */
  _sourcename: MerchantSourceType
  /** The name of the merchant */
  name: Scalars['String']
}

/** Object containing metadata about the interest rate for the mortgage. */
export type PlaidMortgageInterestRate = {
  __typename?: 'PlaidMortgageInterestRate'
  /** Percentage value (interest rate of current mortgage, not APR) of interest payable on a loan. */
  percentage?: Maybe<Scalars['Float']>
  /** The type of interest charged (fixed or variable). */
  type?: Maybe<Scalars['String']>
}

/** Object containing fields describing property address. */
export type PlaidMortgagePropertyAddress = {
  __typename?: 'PlaidMortgagePropertyAddress'
  /** The city name. */
  city?: Maybe<Scalars['String']>
  /** The ISO 3166-1 alpha-2 country code. */
  country?: Maybe<Scalars['String']>
  /** The five or nine digit postal code. */
  postalCode?: Maybe<Scalars['String']>
  /** The region or state (example "NC"). */
  region?: Maybe<Scalars['String']>
  /** The full street address (example "564 Main Street, Apt 15"). */
  street?: Maybe<Scalars['String']>
}

/**
 * Information about the student's eligibility in the Public Service Loan
 * Forgiveness program. This is only returned if the institution is Fedloan (ins_116527).
 */
export type PlaidPslfStatus = {
  __typename?: 'PlaidPSLFStatus'
  /** The estimated date borrower will have completed 120 qualifying monthly payments. */
  estimatedEligibilityDate?: Maybe<Scalars['Date']>
  /** The number of qualifying payments that have been made. */
  paymentsMade?: Maybe<Scalars['Float']>
  /** The number of qualifying payments remaining. */
  paymentsRemaining?: Maybe<Scalars['Float']>
}

/**
 * Transaction information specific to inter-bank transfers. If the transaction was
 * not an inter-bank transfer, all fields will be null.
 */
export type PlaidPaymentMeta = {
  __typename?: 'PlaidPaymentMeta'
  /** The party initiating a wire transfer. Will be null if the transaction is not a wire transfer. */
  byOrderOf?: Maybe<Scalars['String']>
  /** For transfers, the party that is receiving the transaction. */
  payee?: Maybe<Scalars['String']>
  /** For transfers, the party that is paying the transaction. */
  payer?: Maybe<Scalars['String']>
  /** The type of transfer, e.g. 'ACH' */
  paymentMethod?: Maybe<Scalars['String']>
  /** The name of the payment processor */
  paymentProcessor?: Maybe<Scalars['String']>
  /** The ACH PPD ID for the payer. */
  ppdId?: Maybe<Scalars['String']>
  /** The payer-supplied description of the transfer. */
  reason?: Maybe<Scalars['String']>
  /** The transaction reference number supplied by the financial institution. */
  referenceNumber?: Maybe<Scalars['String']>
}

/**
 * Information describing the intent of the transaction. Most relevant for personal
 * finance use cases, but not limited to such use cases.
 */
export type PlaidPersonalFinanceCategory = {
  __typename?: 'PlaidPersonalFinanceCategory'
  /** Provides additional granularity to the primary categorization. */
  detailed: Scalars['String']
  /** A high level category that communicates the broad category of the transaction. */
  primary: Scalars['String']
}

/** Represents a Processor Token */
export type PlaidProcessorToken = {
  __typename?: 'PlaidProcessorToken'
  /** The `processor_token` that can then be used by the Plaid partner to make API requests */
  processorToken: Scalars['ID']
}

/** Autogenerated input type of PlaidProcessorTokenCreate */
export type PlaidProcessorTokenCreateInput = {
  /**
   * The Plaid `account_id` from Plaid Link's `onSuccess` callback or the
   * `accountId` from the Quiltt Account's PlaidAccount source
   */
  accountId: Scalars['ID']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** The ID of the Plaid Item data is being requested for */
  plaidItemId: Scalars['ID']
  /** The processor you are integrating with */
  processor: Scalars['String']
}

/** Autogenerated return type of PlaidProcessorTokenCreate */
export type PlaidProcessorTokenCreatePayload = {
  __typename?: 'PlaidProcessorTokenCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Processor token */
  record?: Maybe<PlaidProcessorToken>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** The address of the student loan servicer. This is generally the remittance address to which payments should be sent. */
export type PlaidServicerAddressData = {
  __typename?: 'PlaidServicerAddressData'
  /** The full city name */
  city?: Maybe<Scalars['String']>
  /** The ISO 3166-1 alpha-2 country code */
  country?: Maybe<Scalars['String']>
  /** The postal code */
  postalCode?: Maybe<Scalars['String']>
  /** The region or state */
  region?: Maybe<Scalars['String']>
  /** The full street address */
  street?: Maybe<Scalars['String']>
}

/** An object representing the status of the student loan */
export type PlaidStudentLoanStatus = {
  __typename?: 'PlaidStudentLoanStatus'
  /** The date until which the loan will be in its current status. */
  endDate?: Maybe<Scalars['Date']>
  /** The status type of the student loan */
  type?: Maybe<Scalars['String']>
}

/** An object representing the repayment plan for the student loan */
export type PlaidStudentRepaymentPlan = {
  __typename?: 'PlaidStudentRepaymentPlan'
  /** The description of the repayment plan as provided by the servicer. */
  description?: Maybe<Scalars['String']>
  /**
   * The type of the repayment plan.
   * Possible values: extended graduated, extended standard, graduated,
   * income-contingent repayment, income-based repayment, interest-only, other, pay
   * as you earn, revised pay as you earn, standard, null
   */
  type?: Maybe<Scalars['String']>
}

/** Plaid Transaction Data */
export type PlaidTransaction = {
  __typename?: 'PlaidTransaction'
  /** API Source */
  _sourcename: TransactionSourceType
  /** The ID of the account in which this transaction occurred. */
  accountId: Scalars['String']
  /** The name of the account owner. This field is not typically populated and only relevant when dealing with sub-accounts. */
  accountOwner?: Maybe<Scalars['String']>
  /**
   * The settled value of the transaction, denominated in the account's currency,
   * as stated in iso_currency_code or unofficial_currency_code. Positive values
   * when money moves out of the account; negative values when money moves in. For
   * example, debit card purchases are positive; credit card payments, direct
   * deposits, and refunds are negative.
   */
  amount: Scalars['Float']
  /** The date that the transaction was authorized. */
  authorizedDate?: Maybe<Scalars['Date']>
  /** Date and time when a transaction was authorized */
  authorizedDatetime?: Maybe<Scalars['DateTime']>
  /** A hierarchical array of the categories to which this transaction belongs. */
  category?: Maybe<Array<Scalars['String']>>
  /** The ID of the category to which this transaction belongs. */
  categoryId?: Maybe<Scalars['String']>
  /** The check number of the transaction. This field is only populated for check transactions. */
  checkNumber?: Maybe<Scalars['String']>
  /**
   * For pending transactions, the date that the transaction occurred; for posted
   * transactions, the date that the transaction posted.
   */
  date: Scalars['Date']
  /** Date and time when a transaction was posted */
  datetime?: Maybe<Scalars['DateTime']>
  /** The ISO-4217 currency code of the transaction. Always null if unofficial_currency_code is non-null. */
  isoCurrencyCode?: Maybe<Scalars['String']>
  /** A representation of where a transaction took place */
  location: PlaidLocation
  /** The merchant name, as extracted by Plaid from the name field. */
  merchantName?: Maybe<Scalars['String']>
  /** The merchant name or transaction description. */
  name: Scalars['String']
  /** The string returned by the financial institution to describe the transaction. */
  originalDescription?: Maybe<Scalars['String']>
  /** The channel used to make a payment. Possible values: online, in store, other */
  paymentChannel: Scalars['String']
  /**
   * Transaction information specific to inter-bank transfers. If the transaction
   * was not an inter-bank transfer, all fields will be null.
   */
  paymentMeta: PlaidPaymentMeta
  /**
   * When true, identifies the transaction as pending or unsettled. Pending
   * transaction details (name, type, amount, category ID) may change before they are settled.
   */
  pending: Scalars['Boolean']
  /** The ID of a posted transaction's associated pending transaction, where applicable. */
  pendingTransactionId?: Maybe<Scalars['String']>
  /**
   * Information describing the intent of the transaction. Most relevant for
   * personal finance use cases, but not limited to such use cases.
   */
  personalFinanceCategory?: Maybe<PlaidPersonalFinanceCategory>
  /**
   * An identifier classifying the transaction type. Possible values: adjustment,
   * atm, bank charge, bill payment, cash, cashback, cheque, direct debit,
   * interest, purchase, standing order, transfer, null
   */
  transactionCode?: Maybe<Scalars['String']>
  /** The unique ID of the transaction. */
  transactionId: Scalars['String']
  /**
   * Please use the payment_channel field, transaction_type will be deprecated in
   * the future. digital: transactions that took place online. place: transactions
   * that were made at a physical location. special: transactions that relate to
   * banks, e.g. fees or deposits. unresolved: transactions that do not fit into
   * the other three types. Possible values: digital, place, special, unresolved
   */
  transactionType: Scalars['String']
  /**
   * The unofficial currency code associated with the transaction. Always null if
   * iso_currency_code is non-null. Unofficial currency codes are used for
   * currencies that do not have official ISO currency codes, such as
   * cryptocurrencies and the currencies of certain countries.
   */
  unofficialCurrencyCode?: Maybe<Scalars['String']>
}

/** Represents a Profile */
export type Profile = {
  __typename?: 'Profile'
  /** Mailing Address */
  address?: Maybe<ProfileAddress>
  /** Birthday */
  dateOfBirth?: Maybe<Scalars['Date']>
  /** Email */
  email?: Maybe<Scalars['String']>
  /** ID */
  id: Scalars['ID']
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
  /** Common or Nickname */
  name?: Maybe<Scalars['String']>
  /** Legal Name */
  names?: Maybe<ProfileName>
  /** Cellphone in E164 Format */
  phone?: Maybe<Scalars['String']>
}

/** Represents an Address */
export type ProfileAddress = {
  __typename?: 'ProfileAddress'
  /** City */
  city?: Maybe<Scalars['String']>
  /** Country Code */
  countryCode?: Maybe<AddressCountryCode>
  /** Line 1 */
  line1?: Maybe<Scalars['String']>
  /** Line 2 */
  line2?: Maybe<Scalars['String']>
  /** Postal Code */
  postalCode?: Maybe<Scalars['String']>
  /** State */
  state?: Maybe<Scalars['String']>
}

/** Attributes for setting an Address */
export type ProfileAddressInput = {
  /** City */
  city: Scalars['String']
  /** Country Code */
  countryCode: AddressCountryCode
  /** Line 1 */
  line1: Scalars['String']
  /** Line 2 */
  line2?: InputMaybe<Scalars['String']>
  /** Postal Code */
  postalCode: Scalars['String']
  /** State */
  state: Scalars['String']
}

/** Represents an Legal Name */
export type ProfileName = {
  __typename?: 'ProfileName'
  /** Given Name */
  first?: Maybe<Scalars['String']>
  /** Full Name */
  full?: Maybe<Scalars['String']>
  /** Surname */
  last?: Maybe<Scalars['String']>
}

/** Attributes for setting a Legal Name */
export type ProfileNameInput = {
  /** Legal Given Name */
  first: Scalars['String']
  /** Legal Surname */
  last: Scalars['String']
}

/** Autogenerated input type of ProfileUpdate */
export type ProfileUpdateInput = {
  /** Mailing Address */
  address?: InputMaybe<ProfileAddressInput>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** Birthday */
  dateOfBirth?: InputMaybe<Scalars['Date']>
  /** Email */
  email?: InputMaybe<Scalars['String']>
  /** Customizable metadata */
  metadata?: InputMaybe<Scalars['JSON']>
  /** Common or Nickname */
  name?: InputMaybe<Scalars['String']>
  /** Legal Name */
  names?: InputMaybe<ProfileNameInput>
  /** Cellphone in E164 Format */
  phone?: InputMaybe<Scalars['String']>
}

/** Autogenerated return type of ProfileUpdate */
export type ProfileUpdatePayload = {
  __typename?: 'ProfileUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated Profile Information */
  record?: Maybe<Profile>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** The top-level Query type. Queries are used to fetch data. */
export type Query = {
  __typename?: 'Query'
  /** Look up an Account by its ID */
  account?: Maybe<Account>
  /** Get a list of Accounts */
  accounts?: Maybe<Array<Account>>
  /** Look up a Connection by its ID */
  connection?: Maybe<ConnectionType>
  /** Get a list of Connections */
  connections?: Maybe<Array<ConnectionType>>
  /** Look up an Merchant by its ID */
  merchant?: Maybe<Merchant>
  /** Get a list of Merchants */
  merchants?: Maybe<Array<Merchant>>
  /**
   * Look up a Plaid Item by its ID
   * @deprecated Use connection
   */
  plaidItem?: Maybe<PlaidItem>
  /**
   * Get a list of Plaid Items
   * @deprecated Use connections
   */
  plaidItems?: Maybe<Array<PlaidItem>>
  /** Get profile information for the authenticated user */
  profile?: Maybe<Profile>
  /** Look up a Recurrence by its ID */
  recurrence?: Maybe<Recurrence>
  /** Get a list of Recurrences */
  recurrences?: Maybe<Array<Recurrence>>
  /** Look up a RoundUp by its ID */
  roundUp?: Maybe<RoundUp>
  /** Get a list of RoundUps */
  roundUps?: Maybe<Array<RoundUp>>
  /** Look up a Transaction by its ID */
  transaction?: Maybe<Transaction>
  /** Get a cursor paginated list of Transactions */
  transactionsConnection: TransactionConnection
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryAccountArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryAccountsArgs = {
  filter?: InputMaybe<AccountFilter>
  search?: InputMaybe<SearchQuery>
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryConnectionArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryMerchantArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryMerchantsArgs = {
  search?: InputMaybe<SearchQuery>
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryPlaidItemArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryRecurrenceArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryRoundUpArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryTransactionArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryTransactionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>
  before?: InputMaybe<Scalars['String']>
  filter?: InputMaybe<TransactionFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  search?: InputMaybe<SearchQuery>
  sort?: InputMaybe<TransactionSort>
}

/** Represents a recurring set of transactions */
export type Recurrence = {
  __typename?: 'Recurrence'
  entryType: RecurrenceEntryType
  frequency: RecurrenceFrequency
  /** ID */
  id: Scalars['ID']
  /** Name */
  name?: Maybe<Scalars['String']>
  /** State */
  state: LedgerState
  /**
   * Status
   * @deprecated Use `state` instead.
   */
  status: LedgerStatus
  /** The next projected payment */
  transactionNext?: Maybe<Transaction>
  /** A limited list of transactions. Use `transactionsConnection` for a full paginated list. */
  transactions: Array<Transaction>
  /** Cursor-based pagination transactions */
  transactionsConnection: TransactionConnection
}

/** Represents a recurring set of transactions */
export type RecurrenceTransactionsArgs = {
  filter?: InputMaybe<TransactionFilter>
  limit?: Scalars['Int']
  search?: InputMaybe<SearchQuery>
  sort?: InputMaybe<TransactionSort>
}

/** Represents a recurring set of transactions */
export type RecurrenceTransactionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>
  before?: InputMaybe<Scalars['String']>
  filter?: InputMaybe<TransactionFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  search?: InputMaybe<SearchQuery>
  sort?: InputMaybe<TransactionSort>
}

/** Whether the Recurrence represent money being advanced into or withdrawn from the account. */
export enum RecurrenceEntryType {
  /** a set of entries recording money being advanced into the account */
  Inflow = 'INFLOW',
  /** a set of entries recording money being withdrawn from the account */
  Outflow = 'OUTFLOW',
}

/** Represents the frequency of a recurring event */
export enum RecurrenceFrequency {
  /** Every year */
  Annually = 'ANNUALLY',
  /** Every daily */
  Daily = 'DAILY',
  /** Every 30 days */
  Every_30Days = 'EVERY_30_DAYS',
  /** Every two weeks */
  Fortnightly = 'FORTNIGHTLY',
  /** Every month */
  Monthly = 'MONTHLY',
  /** Every three months */
  Quarterly = 'QUARTERLY',
  /** Every six months */
  Semiannually = 'SEMIANNUALLY',
  /** Twice per month, 1st & 15th */
  SemimonthlyEarly = 'SEMIMONTHLY_EARLY',
  /** Twice per month, 15th & End of Month */
  SemimonthlyLate = 'SEMIMONTHLY_LATE',
  /** Every week */
  Weekly = 'WEEKLY',
}

/** Represents a RoundUp */
export type RoundUp = {
  __typename?: 'RoundUp'
  /** Eligible accounts available for this RoundUp */
  availableAccounts: Array<Maybe<Account>>
  /** Balance */
  balance: LedgerBalance
  /** Source or Funding account for this RoundUp */
  fundingAccount?: Maybe<Account>
  /** ID */
  id: Scalars['ID']
  /** State */
  state: LedgerState
  /**
   * Status
   * @deprecated Use `state` instead.
   */
  status: LedgerStatus
  /** Accounts subscribed to this RoundUp */
  subscribedAccounts: Array<Maybe<Account>>
  /** A limited list of transactions. Use `transactionsConnection` for a full paginated list. */
  transactions: Array<Transaction>
  /** Cursor-based pagination transactions */
  transactionsConnection: TransactionConnection
}

/** Represents a RoundUp */
export type RoundUpBalanceArgs = {
  filter?: InputMaybe<TransactionFilter>
}

/** Represents a RoundUp */
export type RoundUpTransactionsArgs = {
  filter?: InputMaybe<TransactionFilter>
  limit?: Scalars['Int']
  search?: InputMaybe<SearchQuery>
  sort?: InputMaybe<TransactionSort>
}

/** Represents a RoundUp */
export type RoundUpTransactionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>
  before?: InputMaybe<Scalars['String']>
  filter?: InputMaybe<TransactionFilter>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
  search?: InputMaybe<SearchQuery>
  sort?: InputMaybe<TransactionSort>
}

/** Autogenerated input type of RoundUpCreate */
export type RoundUpCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** ID of destination account */
  destinationId: Scalars['ID']
  /** ID of the funding account */
  fundingAccountId?: InputMaybe<Scalars['ID']>
  /** IDs of subscribed accounts */
  subscribedAccountIds?: InputMaybe<Array<Scalars['ID']>>
}

/** Autogenerated return type of RoundUpCreate */
export type RoundUpCreatePayload = {
  __typename?: 'RoundUpCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Created RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpPause */
export type RoundUpPauseInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpPause */
export type RoundUpPausePayload = {
  __typename?: 'RoundUpPausePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Paused RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpResume */
export type RoundUpResumeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpResume */
export type RoundUpResumePayload = {
  __typename?: 'RoundUpResumePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Resumed RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpSetFundingAccount */
export type RoundUpSetFundingAccountInput = {
  /** ID of the new funding account to use */
  accountId: Scalars['ID']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpSetFundingAccount */
export type RoundUpSetFundingAccountPayload = {
  __typename?: 'RoundUpSetFundingAccountPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpSetStartTime */
export type RoundUpSetStartTimeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
  /** Time to start rounding up at */
  startAt: Scalars['DateTime']
}

/** Autogenerated return type of RoundUpSetStartTime */
export type RoundUpSetStartTimePayload = {
  __typename?: 'RoundUpSetStartTimePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpSubscribedAccountsAdd */
export type RoundUpSubscribedAccountsAddInput = {
  /** IDs of added Accounts */
  accountIds: Array<Scalars['ID']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpSubscribedAccountsAdd */
export type RoundUpSubscribedAccountsAddPayload = {
  __typename?: 'RoundUpSubscribedAccountsAddPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpSubscribedAccountsRemove */
export type RoundUpSubscribedAccountsRemoveInput = {
  /** IDs of removed Accounts */
  accountIds: Array<Scalars['ID']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpSubscribedAccountsRemove */
export type RoundUpSubscribedAccountsRemovePayload = {
  __typename?: 'RoundUpSubscribedAccountsRemovePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Options for Searching */
export type SearchQuery = {
  /** Query for searching */
  term?: InputMaybe<Scalars['String']>
}

/** Spade Location Data */
export type SpadeLocation = {
  __typename?: 'SpadeLocation'
  /** Street and number */
  address?: Maybe<Scalars['String']>
  /** City or town */
  city?: Maybe<Scalars['String']>
  /** Latitude coordinate */
  latitude?: Maybe<Scalars['String']>
  /** Longitude coordinate */
  longitude?: Maybe<Scalars['String']>
  /** State, Province, Territory etc. */
  state?: Maybe<Scalars['String']>
  /** Store number of chain retailer */
  storeNumber?: Maybe<Scalars['String']>
  /** Zip or postal code */
  zipCode?: Maybe<Scalars['String']>
}

/** Spade Logo Data */
export type SpadeLogo = {
  __typename?: 'SpadeLogo'
  /** Name of the logo (for use in logo endpoint, same as path) */
  logoName: Scalars['String']
  /** Path to the image */
  path: Scalars['String']
  /** mime type of image (currently all are PNGs) */
  type: Scalars['String']
  /** Is this logo from our verified logo database */
  verified: Scalars['Boolean']
}

/** Spade Merchant Info Data */
export type SpadeMerchant = {
  __typename?: 'SpadeMerchant'
  /** API Source */
  _sourcename: MerchantSourceType
  hasPhysicalLocations?: Maybe<Scalars['String']>
  name?: Maybe<Scalars['String']>
  verified?: Maybe<Scalars['Boolean']>
  website?: Maybe<Scalars['String']>
}

/** Spade Merchant Info Data */
export type SpadeMerchantInfo = {
  __typename?: 'SpadeMerchantInfo'
  hasPhysicalLocations?: Maybe<Scalars['String']>
  name?: Maybe<Scalars['String']>
  verified?: Maybe<Scalars['Boolean']>
  website?: Maybe<Scalars['String']>
}

/** Spade Transaction Data */
export type SpadeTransaction = {
  __typename?: 'SpadeTransaction'
  /** API Source */
  _sourcename: TransactionSourceType
  /**
   * List of increasingly specific categories based off the given MCC or our
   * merchant database. We reccomend using the second element as a reasonably
   * specific starting point.
   */
  category?: Maybe<Array<Scalars['String']>>
  /** Is likely a recurring transaction */
  isRecurring?: Maybe<Scalars['String']>
  location?: Maybe<SpadeLocation>
  logo?: Maybe<SpadeLogo>
  /** 'Merchant Category Code' (Marqueta, Galileo, etc.) */
  mcc?: Maybe<Scalars['String']>
  merchantInfo?: Maybe<SpadeMerchantInfo>
  /** Name of the merchant */
  merchantName?: Maybe<Scalars['String']>
  /** Our best guess as to what the true merchant name is. Utilizing AI, our database of merchants, and geolocation providers. */
  normalizedMerchantName?: Maybe<Scalars['String']>
  /** 'category_id' from Plaid */
  plaidCategoryId?: Maybe<Scalars['String']>
  /** Description of the transaction (often just called 'name') */
  transactionName?: Maybe<Scalars['String']>
  /** Facilitator of transaction */
  via?: Maybe<Scalars['String']>
}

/** The top-level Subscription type. Subscriptions are used to watch for events emitted from the server. */
export type Subscription = {
  __typename?: 'Subscription'
  /** A plaid item was updated */
  plaidItemUpdated: PlaidItemUpdatedPayload
}

/** The top-level Subscription type. Subscriptions are used to watch for events emitted from the server. */
export type SubscriptionPlaidItemUpdatedArgs = {
  id: Scalars['ID']
}

/** Represents a Transaction */
export type Transaction = {
  __typename?: 'Transaction'
  /** Transaction account */
  account: Account
  /** Amount */
  amount: Scalars['Float']
  /** Date of Record */
  date: Scalars['Date']
  /** Description or Line Item Name */
  description: Scalars['String']
  /** CREDIT or DEBIT */
  entryType: TransactionEntryType
  /** ID */
  id: Scalars['ID']
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
  /** API Transaction Data Source */
  source?: Maybe<TransactionSources>
  /** API Transaction Data Sources */
  sources?: Maybe<Array<TransactionSources>>
  /** Status */
  status: TransactionStatus
}

/** Represents a Transaction */
export type TransactionSourceArgs = {
  type: TransactionSourceType
}

/** Represents a Transaction */
export type TransactionSourcesArgs = {
  types?: InputMaybe<Array<TransactionSourceType>>
}

/** The connection type for Transaction. */
export type TransactionConnection = {
  __typename?: 'TransactionConnection'
  count: Scalars['Int']
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TransactionEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Transaction>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
}

/** An edge in a connection. */
export type TransactionEdge = {
  __typename?: 'TransactionEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<Transaction>
}

/** Whether the Transaction is a CREDIT or DEBIT */
export enum TransactionEntryType {
  /** an entry recording money being advanced into the account */
  Credit = 'CREDIT',
  /** an entry recording money being withdrawn from the account */
  Debit = 'DEBIT',
}

/** Options for Filtering Transactions */
export type TransactionFilter = {
  /** Account IDs */
  accountIds?: InputMaybe<Array<Scalars['ID']>>
  /** Amount */
  amount?: InputMaybe<Scalars['Float']>
  /** Amount */
  amount_abs?: InputMaybe<Scalars['Float']>
  /** Greater than the absolute value of Amount */
  amount_abs_gt?: InputMaybe<Scalars['Float']>
  /** Greater than or equal to the absolute value of Amount */
  amount_abs_gte?: InputMaybe<Scalars['Float']>
  /** Less than the absolute value of Amount */
  amount_abs_lt?: InputMaybe<Scalars['Float']>
  /** Less than or equal to the absolute value of Amount */
  amount_abs_lte?: InputMaybe<Scalars['Float']>
  /** Greater than the Amount */
  amount_gt?: InputMaybe<Scalars['Float']>
  /** Greater than or equal to the Amount */
  amount_gte?: InputMaybe<Scalars['Float']>
  /** Less than the Amount */
  amount_lt?: InputMaybe<Scalars['Float']>
  /** Less than or equal to the Amount */
  amount_lte?: InputMaybe<Scalars['Float']>
  /** Date */
  date?: InputMaybe<Scalars['Date']>
  /** Greater than the Date */
  date_gt?: InputMaybe<Scalars['Date']>
  /** Greater than or equal to the Date */
  date_gte?: InputMaybe<Scalars['Date']>
  /** Less than the Date */
  date_lt?: InputMaybe<Scalars['Date']>
  /** Less than or equal to the Date */
  date_lte?: InputMaybe<Scalars['Date']>
  entryType?: InputMaybe<TransactionEntryType>
  source?: InputMaybe<TransactionFilterSourceInput>
  /** Transaction status */
  status?: InputMaybe<Array<TransactionStatus>>
}

/** Source-specific filters */
export type TransactionFilterSourceInput = {
  plaid?: InputMaybe<TransactionFilterSourcePlaidInput>
}

/** Options for filtering inside Plaid's API payloads */
export type TransactionFilterSourcePlaidInput = {
  /** The ID of the account in which this transaction occurred. */
  accountId?: InputMaybe<Scalars['String']>
  /** The name of the account owner. This field is not typically populated and only relevant when dealing with sub-accounts. */
  accountOwner?: InputMaybe<Scalars['String']>
  /**
   * The settled value of the transaction, denominated in the account's currency,
   * as stated in iso_currency_code or unofficial_currency_code. Positive values
   * when money moves out of the account; negative values when money moves in. For
   * example, debit card purchases are positive; credit card payments, direct
   * deposits, and refunds are negative.
   */
  amount?: InputMaybe<Scalars['Float']>
  /** The date that the transaction was authorized. */
  authorizedDate?: InputMaybe<Scalars['String']>
  /** Date and time when a transaction was authorized */
  authorizedDatetime?: InputMaybe<Scalars['String']>
  /** A hierarchical array of the categories to which this transaction belongs. */
  category?: InputMaybe<Array<Scalars['String']>>
  /** The ID of the category to which this transaction belongs. */
  categoryId?: InputMaybe<Scalars['String']>
  /**
   * For pending transactions, the date that the transaction occurred; for posted
   * transactions, the date that the transaction posted.
   */
  date?: InputMaybe<Scalars['Date']>
  /** Date and time when a transaction was posted */
  datetime?: InputMaybe<Scalars['DateTime']>
  /** The ISO-4217 currency code of the transaction. Always null if unofficial_currency_code is non-null. */
  isoCurrencyCode?: InputMaybe<Scalars['String']>
  location?: InputMaybe<TransactionFilterSourcePlaidLocationInput>
  /** The merchant name, as extracted by Plaid from the name field. */
  merchantName?: InputMaybe<Scalars['String']>
  /** The merchant name or transaction description. */
  name?: InputMaybe<Scalars['String']>
  /** The channel used to make a payment. Possible values: online, in store, other */
  paymentChannel?: InputMaybe<Scalars['String']>
  paymentMeta?: InputMaybe<TransactionFilterSourcePlaidPaymentMetaInput>
  /**
   * When true, identifies the transaction as pending or unsettled. Pending
   * transaction details (name, type, amount, category ID) may change before they are settled.
   */
  pending?: InputMaybe<Scalars['Boolean']>
  /** The ID of a posted transaction's associated pending transaction, where applicable. */
  pendingTransactionId?: InputMaybe<Scalars['String']>
  /**
   * An identifier classifying the transaction type. Possible values: adjustment,
   * atm, bank charge, bill payment, cash, cashback, cheque, direct debit,
   * interest, purchase, standing order, transfer, null
   */
  transactionCode?: InputMaybe<Scalars['String']>
  /** The unique ID of the transaction. */
  transactionId?: InputMaybe<Scalars['String']>
  /**
   * The unofficial currency code associated with the transaction. Always null if
   * iso_currency_code is non-null. Unofficial currency codes are used for
   * currencies that do not have official ISO currency codes, such as
   * cryptocurrencies and the currencies of certain countries.
   */
  unofficialCurrencyCode?: InputMaybe<Scalars['String']>
}

/** Options for filtering inside Plaid's Transaction Location data */
export type TransactionFilterSourcePlaidLocationInput = {
  /** The street address where the transaction occurred. */
  address?: InputMaybe<Scalars['String']>
  /** The city where the transaction occurred. */
  city?: InputMaybe<Scalars['String']>
  /** The ISO 3166-1 alpha-2 country code where the transaction occurred. */
  country?: InputMaybe<Scalars['String']>
  /** The latitude where the transaction occurred. */
  lat?: InputMaybe<Scalars['Float']>
  /** The longitude where the transaction occurred. */
  lon?: InputMaybe<Scalars['Float']>
  /** The postal code where the transaction occurred. */
  postalCode?: InputMaybe<Scalars['String']>
  /** The region or state where the transaction occurred. */
  region?: InputMaybe<Scalars['String']>
  /** The merchant defined store number where the transaction occurred. */
  storeNumber?: InputMaybe<Scalars['String']>
}

/** Options for filtering inside Plaid's Transaction Payment Meta data */
export type TransactionFilterSourcePlaidPaymentMetaInput = {
  /** The party initiating a wire transfer. Will be null if the transaction is not a wire transfer. */
  byOrderOf?: InputMaybe<Scalars['String']>
  /** For transfers, the party that is receiving the transaction. */
  payee?: InputMaybe<Scalars['String']>
  /** For transfers, the party that is paying the transaction. */
  payer?: InputMaybe<Scalars['String']>
  /** The type of transfer, e.g. 'ACH' */
  paymentMethod?: InputMaybe<Scalars['String']>
  /** The name of the payment processor */
  paymentProcessor?: InputMaybe<Scalars['String']>
  /** The ACH PPD ID for the payer. */
  ppdId?: InputMaybe<Scalars['String']>
  /** The payer-supplied description of the transfer. */
  reason?: InputMaybe<Scalars['String']>
  /** The transaction reference number supplied by the financial institution. */
  referenceNumber?: InputMaybe<Scalars['String']>
}

/** Options for Sorting Transactions */
export enum TransactionSort {
  /** Oldest First, Pending Last */
  DateAsc = 'DATE_ASC',
  /** Newest First, Pending First */
  DateDesc = 'DATE_DESC',
}

/** Represents a data source for the Transaction */
export enum TransactionSourceType {
  /** Mock connection */
  Mock = 'MOCK',
  /** MX connection */
  Mx = 'MX',
  /** Plaid connection */
  Plaid = 'PLAID',
  /** Spade Transaction Enrichment */
  Spade = 'SPADE',
}

export type TransactionSources = MockTransaction | PlaidTransaction | SpadeTransaction

/** Represents the pending, posted, or projected status for a transaction */
export enum TransactionStatus {
  /** Awaiting decision or settlement, may be replaced, updated, or removed */
  Pending = 'PENDING',
  /** Announced or published as conclusive */
  Posted = 'POSTED',
  /** Estimated or forecast on the basis of current trends or data */
  Projected = 'PROJECTED',
}

/** Autogenerated input type of TransactionUpdate */
export type TransactionUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>
  id: Scalars['ID']
  /** Customizable metadata */
  metadata?: InputMaybe<Scalars['JSON']>
}

/** Autogenerated return type of TransactionUpdate */
export type TransactionUpdatePayload = {
  __typename?: 'TransactionUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated Account Information */
  record?: Maybe<Account>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

export type ProfileQueryVariables = Exact<{ [key: string]: never }>

export type ProfileQuery = {
  __typename?: 'Query'
  profile?:
    | {
        __typename?: 'Profile'
        name?: string | null | undefined
        email?: string | null | undefined
        phone?: string | null | undefined
        dateOfBirth?: any | null | undefined
        metadata?: any | null | undefined
        names?:
          | {
              __typename?: 'ProfileName'
              first?: string | null | undefined
              last?: string | null | undefined
            }
          | null
          | undefined
        address?:
          | {
              __typename?: 'ProfileAddress'
              line1?: string | null | undefined
              line2?: string | null | undefined
              city?: string | null | undefined
              state?: string | null | undefined
              postalCode?: string | null | undefined
              countryCode?: AddressCountryCode | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type ProfileUpdateMutationVariables = Exact<{
  input: ProfileUpdateInput
}>

export type ProfileUpdateMutation = {
  __typename?: 'Mutation'
  profileUpdate?:
    | {
        __typename?: 'ProfileUpdatePayload'
        record?:
          | {
              __typename?: 'Profile'
              name?: string | null | undefined
              email?: string | null | undefined
              phone?: string | null | undefined
              dateOfBirth?: any | null | undefined
              metadata?: any | null | undefined
              names?:
                | {
                    __typename?: 'ProfileName'
                    first?: string | null | undefined
                    last?: string | null | undefined
                  }
                | null
                | undefined
              address?:
                | {
                    __typename?: 'ProfileAddress'
                    line1?: string | null | undefined
                    line2?: string | null | undefined
                    city?: string | null | undefined
                    state?: string | null | undefined
                    postalCode?: string | null | undefined
                    countryCode?: AddressCountryCode | null | undefined
                  }
                | null
                | undefined
            }
          | null
          | undefined
        errors?:
          | Array<{
              __typename?: 'Error'
              path?: Array<string> | null | undefined
              message?: string | null | undefined
            }>
          | null
          | undefined
      }
    | null
    | undefined
}

export type BillsQueryVariables = Exact<{ [key: string]: never }>

export type BillsQuery = {
  __typename?: 'Query'
  recurrences?:
    | Array<{
        __typename?: 'Recurrence'
        id: string
        name?: string | null | undefined
        frequency: RecurrenceFrequency
        state: LedgerState
        transactionNext?:
          | { __typename?: 'Transaction'; id: string; date: any; amount: number }
          | null
          | undefined
      }>
    | null
    | undefined
}

export type BillDetailQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type BillDetailQuery = {
  __typename?: 'Query'
  recurrence?:
    | {
        __typename?: 'Recurrence'
        id: string
        name?: string | null | undefined
        frequency: RecurrenceFrequency
        state: LedgerState
        transactionNext?:
          | { __typename?: 'Transaction'; id: string; date: any; amount: number }
          | null
          | undefined
        transactions: Array<{ __typename?: 'Transaction'; id: string; amount: number; date: any }>
      }
    | null
    | undefined
}

export type PlaidItemsQueryVariables = Exact<{ [key: string]: never }>

export type PlaidItemsQuery = {
  __typename?: 'Query'
  plaidItems?:
    | Array<{
        __typename?: 'PlaidItem'
        id: string
        name: string
        status: PlaidItemStatus
        syncedAt?: any | null | undefined
        logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
        accounts: Array<{
          __typename?: 'Account'
          id: string
          name: string
          lastFourDigits?: string | null | undefined
          type: AccountType
          balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
        }>
      }>
    | null
    | undefined
}

export type PlaidItemSyncStatusQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type PlaidItemSyncStatusQuery = {
  __typename?: 'Query'
  plaidItem?:
    | {
        __typename?: 'PlaidItem'
        id: string
        status: PlaidItemStatus
        syncedAt?: any | null | undefined
      }
    | null
    | undefined
}

export type PlaidLinkTokenCreateMutationVariables = Exact<{
  input: PlaidLinkTokenCreateInput
}>

export type PlaidLinkTokenCreateMutation = {
  __typename?: 'Mutation'
  plaidLinkTokenCreate?:
    | {
        __typename?: 'PlaidLinkTokenCreatePayload'
        record?:
          | { __typename?: 'PlaidLinkToken'; linkToken: string; expiration: any }
          | null
          | undefined
        errors?:
          | Array<{
              __typename?: 'PlaidAPIError'
              code: string
              type: string
              message: string
              requestId?: string | null | undefined
              displayMessage?: string | null | undefined
            }>
          | null
          | undefined
      }
    | null
    | undefined
}

export type PlaidLinkTokenCreateForUpdateMutationVariables = Exact<{
  input: PlaidLinkTokenCreateForUpdateInput
}>

export type PlaidLinkTokenCreateForUpdateMutation = {
  __typename?: 'Mutation'
  plaidLinkTokenCreateForUpdate?:
    | {
        __typename?: 'PlaidLinkTokenCreateForUpdatePayload'
        record?:
          | { __typename?: 'PlaidLinkToken'; linkToken: string; expiration: any }
          | null
          | undefined
        errors?:
          | Array<{
              __typename?: 'PlaidAPIError'
              code: string
              type: string
              message: string
              requestId?: string | null | undefined
              displayMessage?: string | null | undefined
            }>
          | null
          | undefined
      }
    | null
    | undefined
}

export type PlaidItemCreateMutationVariables = Exact<{
  input: PlaidItemCreateInput
}>

export type PlaidItemCreateMutation = {
  __typename?: 'Mutation'
  plaidItemCreate?:
    | {
        __typename?: 'PlaidItemCreatePayload'
        record?:
          | {
              __typename?: 'PlaidItem'
              id: string
              name: string
              status: PlaidItemStatus
              syncedAt?: any | null | undefined
              logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
              accounts: Array<{
                __typename?: 'Account'
                id: string
                name: string
                lastFourDigits?: string | null | undefined
                type: AccountType
                balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
              }>
            }
          | null
          | undefined
        errors?:
          | Array<{ __typename?: 'PlaidAPIError'; displayMessage?: string | null | undefined }>
          | null
          | undefined
      }
    | null
    | undefined
}

export type PlaidItemUnlinkMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type PlaidItemUnlinkMutation = {
  __typename?: 'Mutation'
  plaidItemDelete?:
    | {
        __typename?: 'PlaidItemDeletePayload'
        success: boolean
        record?: { __typename?: 'PlaidItem'; id: string } | null | undefined
      }
    | null
    | undefined
}

export type PlaidItemUpdatedSubscriptionVariables = Exact<{
  id: Scalars['ID']
}>

export type PlaidItemUpdatedSubscription = {
  __typename?: 'Subscription'
  plaidItemUpdated: {
    __typename?: 'PlaidItemUpdatedPayload'
    record?:
      | {
          __typename?: 'PlaidItem'
          id: string
          name: string
          status: PlaidItemStatus
          syncedAt?: any | null | undefined
          logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
          accounts: Array<{
            __typename?: 'Account'
            id: string
            name: string
            lastFourDigits?: string | null | undefined
            type: AccountType
            balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
          }>
        }
      | null
      | undefined
  }
}

export type TransactionsByAccountQueryVariables = Exact<{
  id: Scalars['ID']
  after?: InputMaybe<Scalars['String']>
  before?: InputMaybe<Scalars['String']>
  first?: InputMaybe<Scalars['Int']>
  last?: InputMaybe<Scalars['Int']>
}>

export type TransactionsByAccountQuery = {
  __typename?: 'Query'
  account?:
    | {
        __typename?: 'Account'
        id: string
        lastFourDigits?: string | null | undefined
        metadata?: any | null | undefined
        name: string
        transactionsConnection: {
          __typename?: 'TransactionConnection'
          count: number
          pageInfo: {
            __typename?: 'PageInfo'
            endCursor?: string | null | undefined
            hasNextPage: boolean
            hasPreviousPage: boolean
            startCursor?: string | null | undefined
          }
          edges?:
            | Array<
                | {
                    __typename?: 'TransactionEdge'
                    cursor: string
                    node?:
                      | {
                          __typename?: 'Transaction'
                          id: string
                          description: string
                          amount: number
                          date: any
                          entryType: TransactionEntryType
                          status: TransactionStatus
                          sources?:
                            | Array<
                                | { __typename?: 'MockTransaction' }
                                | { __typename?: 'PlaidTransaction' }
                                | {
                                    __typename?: 'SpadeTransaction'
                                    normalizedMerchantName?: string | null | undefined
                                    logo?:
                                      | {
                                          __typename?: 'SpadeLogo'
                                          path: string
                                          verified: boolean
                                        }
                                      | null
                                      | undefined
                                  }
                              >
                            | null
                            | undefined
                        }
                      | null
                      | undefined
                  }
                | null
                | undefined
              >
            | null
            | undefined
        }
      }
    | null
    | undefined
}

export type NextPaycheckQueryQueryVariables = Exact<{ [key: string]: never }>

export type NextPaycheckQueryQuery = {
  __typename?: 'Query'
  profile?: { __typename?: 'Profile'; name?: string | null | undefined } | null | undefined
}

export type RoundUpActivateMutationVariables = Exact<{
  id: Scalars['ID']
  startAt: Scalars['DateTime']
  startOn?: InputMaybe<Scalars['Date']>
}>

export type RoundUpActivateMutation = {
  __typename?: 'Mutation'
  roundUpSetStartTime?:
    | {
        __typename?: 'RoundUpSetStartTimePayload'
        success: boolean
        record?:
          | {
              __typename?: 'RoundUp'
              id: string
              balance: {
                __typename?: 'LedgerBalance'
                id: string
                available?: number | null | undefined
              }
              transactionsConnection: {
                __typename?: 'TransactionConnection'
                nodes?:
                  | Array<
                      | {
                          __typename?: 'Transaction'
                          id: string
                          date: any
                          amount: number
                          description: string
                        }
                      | null
                      | undefined
                    >
                  | null
                  | undefined
              }
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type RoundUpActivateDateSearchQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpActivateDateSearchQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        subscribedAccounts: Array<
          | {
              __typename?: 'Account'
              id: string
              transactions: Array<{
                __typename?: 'Transaction'
                id: string
                date: any
                amount: number
                status: TransactionStatus
              }>
            }
          | null
          | undefined
        >
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsAccountsListQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  bankConnectionId: Scalars['ID']
}>

export type RoundUpsBankConnectionsAccountsListQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
            }
          | null
          | undefined
      }
    | null
    | undefined
  plaidItem?:
    | {
        __typename?: 'PlaidItem'
        id: string
        name: string
        status: PlaidItemStatus
        syncedAt?: any | null | undefined
        logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
        accounts: Array<{ __typename?: 'Account'; id: string; name: string }>
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsAccountsListItemQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  accountId: Scalars['ID']
}>

export type RoundUpsBankConnectionsAccountsListItemQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
            }
          | null
          | undefined
        subscribedAccounts: Array<{ __typename?: 'Account'; id: string } | null | undefined>
        availableAccounts: Array<{ __typename?: 'Account'; id: string } | null | undefined>
      }
    | null
    | undefined
  account?:
    | {
        __typename?: 'Account'
        id: string
        name: string
        lastFourDigits?: string | null | undefined
        balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
      }
    | null
    | undefined
}

export type RoundUpsAccountsSubscribeMutationVariables = Exact<{
  id: Scalars['ID']
  accountId: Scalars['ID']
}>

export type RoundUpsAccountsSubscribeMutation = {
  __typename?: 'Mutation'
  roundUpSubscribedAccountsAdd?:
    | {
        __typename?: 'RoundUpSubscribedAccountsAddPayload'
        record?:
          | {
              __typename?: 'RoundUp'
              id: string
              subscribedAccounts: Array<{ __typename?: 'Account'; id: string } | null | undefined>
              availableAccounts: Array<{ __typename?: 'Account'; id: string } | null | undefined>
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type RoundUpsAccountsUnsubscribeMutationVariables = Exact<{
  id: Scalars['ID']
  accountId: Scalars['ID']
}>

export type RoundUpsAccountsUnsubscribeMutation = {
  __typename?: 'Mutation'
  roundUpSubscribedAccountsRemove?:
    | {
        __typename?: 'RoundUpSubscribedAccountsRemovePayload'
        record?:
          | {
              __typename?: 'RoundUp'
              id: string
              subscribedAccounts: Array<{ __typename?: 'Account'; id: string } | null | undefined>
              availableAccounts: Array<{ __typename?: 'Account'; id: string } | null | undefined>
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsAddFundingMutationVariables = Exact<{
  roundUpId: Scalars['ID']
  accountId: Scalars['ID']
}>

export type RoundUpsBankConnectionsAddFundingMutation = {
  __typename?: 'Mutation'
  roundUpSetFundingAccount?:
    | {
        __typename?: 'RoundUpSetFundingAccountPayload'
        success: boolean
        record?: { __typename?: 'RoundUp'; id: string } | null | undefined
      }
    | null
    | undefined
  roundUpSubscribedAccountsAdd?:
    | {
        __typename?: 'RoundUpSubscribedAccountsAddPayload'
        success: boolean
        record?: { __typename?: 'RoundUp'; id: string } | null | undefined
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsAddSubscriptionMutationVariables = Exact<{
  roundUpId: Scalars['ID']
  accountIds: Array<Scalars['ID']> | Scalars['ID']
}>

export type RoundUpsBankConnectionsAddSubscriptionMutation = {
  __typename?: 'Mutation'
  roundUpSubscribedAccountsAdd?:
    | {
        __typename?: 'RoundUpSubscribedAccountsAddPayload'
        success: boolean
        record?: { __typename?: 'RoundUp'; id: string } | null | undefined
      }
    | null
    | undefined
}

export type RoundUpsRecentActivityQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  since: Scalars['Date']
}>

export type RoundUpsRecentActivityQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        recentActivity: {
          __typename?: 'LedgerBalance'
          id: string
          current?: number | null | undefined
        }
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsSummaryCardFooterQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpsBankConnectionsSummaryCardFooterQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsSummaryCardHeaderQueryVariables = Exact<{ [key: string]: never }>

export type RoundUpsBankConnectionsSummaryCardHeaderQuery = {
  __typename?: 'Query'
  plaidItems?: Array<{ __typename?: 'PlaidItem'; id: string }> | null | undefined
}

export type RoundUpsBankConnectionsCardQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  id: Scalars['ID']
}>

export type RoundUpsBankConnectionsCardQuery = {
  __typename?: 'Query'
  roundUp?: { __typename?: 'RoundUp'; id: string } | null | undefined
  plaidItem?:
    | {
        __typename?: 'PlaidItem'
        id: string
        name: string
        status: PlaidItemStatus
        syncedAt?: any | null | undefined
        logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsListQueryVariables = Exact<{
  roundUpId: Scalars['ID']
}>

export type RoundUpsBankConnectionsListQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              lastFourDigits?: string | null | undefined
              name: string
              type: AccountType
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
              plaidItem?: { __typename?: 'PlaidItem'; id: string } | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
  plaidItems?:
    | Array<{
        __typename?: 'PlaidItem'
        id: string
        name: string
        status: PlaidItemStatus
        syncedAt?: any | null | undefined
        logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
      }>
    | null
    | undefined
}

export type RoundUpsBankConnectionsListItemQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  id: Scalars['ID']
}>

export type RoundUpsBankConnectionsListItemQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              lastFourDigits?: string | null | undefined
              name: string
              type: AccountType
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
              plaidItem?: { __typename?: 'PlaidItem'; id: string } | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
  plaidItem?:
    | {
        __typename?: 'PlaidItem'
        id: string
        name: string
        status: PlaidItemStatus
        syncedAt?: any | null | undefined
        logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
      }
    | null
    | undefined
}

export type RoundUpsBankConnectionsPageQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpsBankConnectionsPageQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
            }
          | null
          | undefined
      }
    | null
    | undefined
  plaidItems?:
    | Array<{
        __typename?: 'PlaidItem'
        id: string
        accounts: Array<{ __typename?: 'Account'; id: string }>
      }>
    | null
    | undefined
}

export type RoundUpsPauseMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpsPauseMutation = {
  __typename?: 'Mutation'
  roundUpPause?:
    | {
        __typename?: 'RoundUpPausePayload'
        record?: { __typename?: 'RoundUp'; id: string; status: LedgerStatus } | null | undefined
      }
    | null
    | undefined
}

export type RoundUpsResumeMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpsResumeMutation = {
  __typename?: 'Mutation'
  roundUpResume?:
    | {
        __typename?: 'RoundUpResumePayload'
        record?: { __typename?: 'RoundUp'; id: string; status: LedgerStatus } | null | undefined
      }
    | null
    | undefined
}

export type RoundUpSummaryQueryVariables = Exact<{
  id: Scalars['ID']
  startOfWeek?: InputMaybe<Scalars['Date']>
}>

export type RoundUpSummaryQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        totalAmount: {
          __typename?: 'LedgerBalance'
          id: string
          available?: number | null | undefined
          current?: number | null | undefined
        }
        thisWeek: {
          __typename?: 'LedgerBalance'
          id: string
          available?: number | null | undefined
          current?: number | null | undefined
        }
      }
    | null
    | undefined
}

export type RoundUpHistoryQueryVariables = Exact<{
  id: Scalars['ID']
  day0: Scalars['Date']
  day1: Scalars['Date']
  day2: Scalars['Date']
  day3: Scalars['Date']
  day4: Scalars['Date']
  day5: Scalars['Date']
  day6: Scalars['Date']
}>

export type RoundUpHistoryQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        day0: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
        day1: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
        day2: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
        day3: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
        day4: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
        day5: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
        day6: { __typename?: 'LedgerBalance'; id: string; available?: number | null | undefined }
      }
    | null
    | undefined
}

export type RoundUpTransactionsQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpTransactionsQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        transactionsConnection: {
          __typename?: 'TransactionConnection'
          edges?:
            | Array<
                | {
                    __typename?: 'TransactionEdge'
                    node?:
                      | {
                          __typename?: 'Transaction'
                          id: string
                          date: any
                          amount: number
                          description: string
                        }
                      | null
                      | undefined
                  }
                | null
                | undefined
              >
            | null
            | undefined
        }
      }
    | null
    | undefined
}

export type RoundUpsQueryVariables = Exact<{ [key: string]: never }>

export type RoundUpsQuery = {
  __typename?: 'Query'
  roundUps?: Array<{ __typename?: 'RoundUp'; id: string }> | null | undefined
}

export type RoundUpHomeQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpHomeQuery = {
  __typename?: 'Query'
  roundUp?:
    | {
        __typename?: 'RoundUp'
        id: string
        status: LedgerStatus
        fundingAccount?:
          | {
              __typename?: 'Account'
              id: string
              balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type CreateRoundUpMutationVariables = Exact<{
  input: RoundUpCreateInput
}>

export type CreateRoundUpMutation = {
  __typename?: 'Mutation'
  roundUpCreate?:
    | {
        __typename?: 'RoundUpCreatePayload'
        success: boolean
        record?: { __typename?: 'RoundUp'; id: string; status: LedgerStatus } | null | undefined
      }
    | null
    | undefined
}

export type AccountAttributesFragment = {
  __typename?: 'Account'
  id: string
  lastFourDigits?: string | null | undefined
  name: string
  type: AccountType
  plaidItem?: { __typename?: 'PlaidItem'; id: string } | null | undefined
}

export type PlaidItemAttributesFragment = {
  __typename?: 'PlaidItem'
  id: string
  name: string
  status: PlaidItemStatus
  syncedAt?: any | null | undefined
  logo?: { __typename?: 'Image'; url?: any | null | undefined } | null | undefined
  accounts: Array<{
    __typename?: 'Account'
    id: string
    name: string
    lastFourDigits?: string | null | undefined
    type: AccountType
    balance: { __typename?: 'LedgerBalance'; current?: number | null | undefined }
  }>
}

export type ProfileAttributesFragment = {
  __typename?: 'Profile'
  name?: string | null | undefined
  email?: string | null | undefined
  phone?: string | null | undefined
  dateOfBirth?: any | null | undefined
  metadata?: any | null | undefined
  names?:
    | {
        __typename?: 'ProfileName'
        first?: string | null | undefined
        last?: string | null | undefined
      }
    | null
    | undefined
  address?:
    | {
        __typename?: 'ProfileAddress'
        line1?: string | null | undefined
        line2?: string | null | undefined
        city?: string | null | undefined
        state?: string | null | undefined
        postalCode?: string | null | undefined
        countryCode?: AddressCountryCode | null | undefined
      }
    | null
    | undefined
}

export const AccountAttributesFragmentDoc = gql`
  fragment AccountAttributes on Account {
    id
    lastFourDigits
    name
    type
    plaidItem {
      id
    }
  }
`
export const PlaidItemAttributesFragmentDoc = gql`
  fragment PlaidItemAttributes on PlaidItem {
    id
    name
    logo {
      url
    }
    status
    syncedAt
    accounts {
      id
      name
      balance {
        current
      }
      lastFourDigits
      type
    }
  }
`
export const ProfileAttributesFragmentDoc = gql`
  fragment ProfileAttributes on Profile {
    name
    names {
      first
      last
    }
    email
    phone
    dateOfBirth
    address {
      line1
      line2
      city
      state
      postalCode
      countryCode
    }
    metadata
  }
`
export const ProfileDocument = gql`
  query Profile {
    profile {
      ...ProfileAttributes
    }
  }
  ${ProfileAttributesFragmentDoc}
`

/**
 * __useProfileQuery__
 *
 * To run a query within a React component, call `useProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileQuery({
 *   variables: {
 *   },
 * });
 */
export function useProfileQuery(
  baseOptions?: Apollo.QueryHookOptions<ProfileQuery, ProfileQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<ProfileQuery, ProfileQueryVariables>(ProfileDocument, options)
}
export function useProfileLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<ProfileQuery, ProfileQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<ProfileQuery, ProfileQueryVariables>(ProfileDocument, options)
}
export type ProfileQueryHookResult = ReturnType<typeof useProfileQuery>
export type ProfileLazyQueryHookResult = ReturnType<typeof useProfileLazyQuery>
export type ProfileQueryResult = Apollo.QueryResult<ProfileQuery, ProfileQueryVariables>
export const ProfileUpdateDocument = gql`
  mutation ProfileUpdate($input: ProfileUpdateInput!) {
    profileUpdate(input: $input) {
      record {
        ...ProfileAttributes
      }
      errors {
        path
        message
      }
    }
  }
  ${ProfileAttributesFragmentDoc}
`
export type ProfileUpdateMutationFn = Apollo.MutationFunction<
  ProfileUpdateMutation,
  ProfileUpdateMutationVariables
>

/**
 * __useProfileUpdateMutation__
 *
 * To run a mutation, you first call `useProfileUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProfileUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [profileUpdateMutation, { data, loading, error }] = useProfileUpdateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useProfileUpdateMutation(
  baseOptions?: Apollo.MutationHookOptions<ProfileUpdateMutation, ProfileUpdateMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<ProfileUpdateMutation, ProfileUpdateMutationVariables>(
    ProfileUpdateDocument,
    options
  )
}
export type ProfileUpdateMutationHookResult = ReturnType<typeof useProfileUpdateMutation>
export type ProfileUpdateMutationResult = Apollo.MutationResult<ProfileUpdateMutation>
export type ProfileUpdateMutationOptions = Apollo.BaseMutationOptions<
  ProfileUpdateMutation,
  ProfileUpdateMutationVariables
>
export const BillsDocument = gql`
  query Bills {
    recurrences {
      id
      name
      frequency
      state
      transactionNext {
        id
        date
        amount
      }
    }
  }
`

/**
 * __useBillsQuery__
 *
 * To run a query within a React component, call `useBillsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBillsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBillsQuery({
 *   variables: {
 *   },
 * });
 */
export function useBillsQuery(
  baseOptions?: Apollo.QueryHookOptions<BillsQuery, BillsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<BillsQuery, BillsQueryVariables>(BillsDocument, options)
}
export function useBillsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<BillsQuery, BillsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<BillsQuery, BillsQueryVariables>(BillsDocument, options)
}
export type BillsQueryHookResult = ReturnType<typeof useBillsQuery>
export type BillsLazyQueryHookResult = ReturnType<typeof useBillsLazyQuery>
export type BillsQueryResult = Apollo.QueryResult<BillsQuery, BillsQueryVariables>
export const BillDetailDocument = gql`
  query BillDetail($id: ID!) {
    recurrence(id: $id) {
      id
      name
      frequency
      state
      transactionNext {
        id
        date
        amount
      }
      transactions {
        id
        amount
        date
      }
    }
  }
`

/**
 * __useBillDetailQuery__
 *
 * To run a query within a React component, call `useBillDetailQuery` and pass it any options that fit your needs.
 * When your component renders, `useBillDetailQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBillDetailQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useBillDetailQuery(
  baseOptions: Apollo.QueryHookOptions<BillDetailQuery, BillDetailQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<BillDetailQuery, BillDetailQueryVariables>(BillDetailDocument, options)
}
export function useBillDetailLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<BillDetailQuery, BillDetailQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<BillDetailQuery, BillDetailQueryVariables>(BillDetailDocument, options)
}
export type BillDetailQueryHookResult = ReturnType<typeof useBillDetailQuery>
export type BillDetailLazyQueryHookResult = ReturnType<typeof useBillDetailLazyQuery>
export type BillDetailQueryResult = Apollo.QueryResult<BillDetailQuery, BillDetailQueryVariables>
export const PlaidItemsDocument = gql`
  query PlaidItems {
    plaidItems {
      ...PlaidItemAttributes
    }
  }
  ${PlaidItemAttributesFragmentDoc}
`

/**
 * __usePlaidItemsQuery__
 *
 * To run a query within a React component, call `usePlaidItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlaidItemsQuery({
 *   variables: {
 *   },
 * });
 */
export function usePlaidItemsQuery(
  baseOptions?: Apollo.QueryHookOptions<PlaidItemsQuery, PlaidItemsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<PlaidItemsQuery, PlaidItemsQueryVariables>(PlaidItemsDocument, options)
}
export function usePlaidItemsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<PlaidItemsQuery, PlaidItemsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<PlaidItemsQuery, PlaidItemsQueryVariables>(PlaidItemsDocument, options)
}
export type PlaidItemsQueryHookResult = ReturnType<typeof usePlaidItemsQuery>
export type PlaidItemsLazyQueryHookResult = ReturnType<typeof usePlaidItemsLazyQuery>
export type PlaidItemsQueryResult = Apollo.QueryResult<PlaidItemsQuery, PlaidItemsQueryVariables>
export const PlaidItemSyncStatusDocument = gql`
  query PlaidItemSyncStatus($id: ID!) {
    plaidItem(id: $id) {
      id
      status
      syncedAt
    }
  }
`

/**
 * __usePlaidItemSyncStatusQuery__
 *
 * To run a query within a React component, call `usePlaidItemSyncStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemSyncStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlaidItemSyncStatusQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlaidItemSyncStatusQuery(
  baseOptions: Apollo.QueryHookOptions<PlaidItemSyncStatusQuery, PlaidItemSyncStatusQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<PlaidItemSyncStatusQuery, PlaidItemSyncStatusQueryVariables>(
    PlaidItemSyncStatusDocument,
    options
  )
}
export function usePlaidItemSyncStatusLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    PlaidItemSyncStatusQuery,
    PlaidItemSyncStatusQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<PlaidItemSyncStatusQuery, PlaidItemSyncStatusQueryVariables>(
    PlaidItemSyncStatusDocument,
    options
  )
}
export type PlaidItemSyncStatusQueryHookResult = ReturnType<typeof usePlaidItemSyncStatusQuery>
export type PlaidItemSyncStatusLazyQueryHookResult = ReturnType<
  typeof usePlaidItemSyncStatusLazyQuery
>
export type PlaidItemSyncStatusQueryResult = Apollo.QueryResult<
  PlaidItemSyncStatusQuery,
  PlaidItemSyncStatusQueryVariables
>
export const PlaidLinkTokenCreateDocument = gql`
  mutation PlaidLinkTokenCreate($input: PlaidLinkTokenCreateInput!) {
    plaidLinkTokenCreate(input: $input) {
      record {
        linkToken
        expiration
      }
      errors {
        code
        type
        message
        requestId
        displayMessage
      }
    }
  }
`
export type PlaidLinkTokenCreateMutationFn = Apollo.MutationFunction<
  PlaidLinkTokenCreateMutation,
  PlaidLinkTokenCreateMutationVariables
>

/**
 * __usePlaidLinkTokenCreateMutation__
 *
 * To run a mutation, you first call `usePlaidLinkTokenCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlaidLinkTokenCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [plaidLinkTokenCreateMutation, { data, loading, error }] = usePlaidLinkTokenCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlaidLinkTokenCreateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PlaidLinkTokenCreateMutation,
    PlaidLinkTokenCreateMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<PlaidLinkTokenCreateMutation, PlaidLinkTokenCreateMutationVariables>(
    PlaidLinkTokenCreateDocument,
    options
  )
}
export type PlaidLinkTokenCreateMutationHookResult = ReturnType<
  typeof usePlaidLinkTokenCreateMutation
>
export type PlaidLinkTokenCreateMutationResult = Apollo.MutationResult<PlaidLinkTokenCreateMutation>
export type PlaidLinkTokenCreateMutationOptions = Apollo.BaseMutationOptions<
  PlaidLinkTokenCreateMutation,
  PlaidLinkTokenCreateMutationVariables
>
export const PlaidLinkTokenCreateForUpdateDocument = gql`
  mutation PlaidLinkTokenCreateForUpdate($input: PlaidLinkTokenCreateForUpdateInput!) {
    plaidLinkTokenCreateForUpdate(input: $input) {
      record {
        linkToken
        expiration
      }
      errors {
        code
        type
        message
        requestId
        displayMessage
      }
    }
  }
`
export type PlaidLinkTokenCreateForUpdateMutationFn = Apollo.MutationFunction<
  PlaidLinkTokenCreateForUpdateMutation,
  PlaidLinkTokenCreateForUpdateMutationVariables
>

/**
 * __usePlaidLinkTokenCreateForUpdateMutation__
 *
 * To run a mutation, you first call `usePlaidLinkTokenCreateForUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlaidLinkTokenCreateForUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [plaidLinkTokenCreateForUpdateMutation, { data, loading, error }] = usePlaidLinkTokenCreateForUpdateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlaidLinkTokenCreateForUpdateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PlaidLinkTokenCreateForUpdateMutation,
    PlaidLinkTokenCreateForUpdateMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    PlaidLinkTokenCreateForUpdateMutation,
    PlaidLinkTokenCreateForUpdateMutationVariables
  >(PlaidLinkTokenCreateForUpdateDocument, options)
}
export type PlaidLinkTokenCreateForUpdateMutationHookResult = ReturnType<
  typeof usePlaidLinkTokenCreateForUpdateMutation
>
export type PlaidLinkTokenCreateForUpdateMutationResult =
  Apollo.MutationResult<PlaidLinkTokenCreateForUpdateMutation>
export type PlaidLinkTokenCreateForUpdateMutationOptions = Apollo.BaseMutationOptions<
  PlaidLinkTokenCreateForUpdateMutation,
  PlaidLinkTokenCreateForUpdateMutationVariables
>
export const PlaidItemCreateDocument = gql`
  mutation PlaidItemCreate($input: PlaidItemCreateInput!) {
    plaidItemCreate(input: $input) {
      record {
        ...PlaidItemAttributes
      }
      errors {
        displayMessage
      }
    }
  }
  ${PlaidItemAttributesFragmentDoc}
`
export type PlaidItemCreateMutationFn = Apollo.MutationFunction<
  PlaidItemCreateMutation,
  PlaidItemCreateMutationVariables
>

/**
 * __usePlaidItemCreateMutation__
 *
 * To run a mutation, you first call `usePlaidItemCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [plaidItemCreateMutation, { data, loading, error }] = usePlaidItemCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlaidItemCreateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PlaidItemCreateMutation,
    PlaidItemCreateMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<PlaidItemCreateMutation, PlaidItemCreateMutationVariables>(
    PlaidItemCreateDocument,
    options
  )
}
export type PlaidItemCreateMutationHookResult = ReturnType<typeof usePlaidItemCreateMutation>
export type PlaidItemCreateMutationResult = Apollo.MutationResult<PlaidItemCreateMutation>
export type PlaidItemCreateMutationOptions = Apollo.BaseMutationOptions<
  PlaidItemCreateMutation,
  PlaidItemCreateMutationVariables
>
export const PlaidItemUnlinkDocument = gql`
  mutation PlaidItemUnlink($id: ID!) {
    plaidItemDelete(input: { id: $id }) {
      success
      record {
        id
      }
    }
  }
`
export type PlaidItemUnlinkMutationFn = Apollo.MutationFunction<
  PlaidItemUnlinkMutation,
  PlaidItemUnlinkMutationVariables
>

/**
 * __usePlaidItemUnlinkMutation__
 *
 * To run a mutation, you first call `usePlaidItemUnlinkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemUnlinkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [plaidItemUnlinkMutation, { data, loading, error }] = usePlaidItemUnlinkMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlaidItemUnlinkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PlaidItemUnlinkMutation,
    PlaidItemUnlinkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<PlaidItemUnlinkMutation, PlaidItemUnlinkMutationVariables>(
    PlaidItemUnlinkDocument,
    options
  )
}
export type PlaidItemUnlinkMutationHookResult = ReturnType<typeof usePlaidItemUnlinkMutation>
export type PlaidItemUnlinkMutationResult = Apollo.MutationResult<PlaidItemUnlinkMutation>
export type PlaidItemUnlinkMutationOptions = Apollo.BaseMutationOptions<
  PlaidItemUnlinkMutation,
  PlaidItemUnlinkMutationVariables
>
export const PlaidItemUpdatedDocument = gql`
  subscription PlaidItemUpdated($id: ID!) {
    plaidItemUpdated(id: $id) {
      record {
        ...PlaidItemAttributes
      }
    }
  }
  ${PlaidItemAttributesFragmentDoc}
`

/**
 * __usePlaidItemUpdatedSubscription__
 *
 * To run a query within a React component, call `usePlaidItemUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlaidItemUpdatedSubscription({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlaidItemUpdatedSubscription(
  baseOptions: Apollo.SubscriptionHookOptions<
    PlaidItemUpdatedSubscription,
    PlaidItemUpdatedSubscriptionVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSubscription<
    PlaidItemUpdatedSubscription,
    PlaidItemUpdatedSubscriptionVariables
  >(PlaidItemUpdatedDocument, options)
}
export type PlaidItemUpdatedSubscriptionHookResult = ReturnType<
  typeof usePlaidItemUpdatedSubscription
>
export type PlaidItemUpdatedSubscriptionResult =
  Apollo.SubscriptionResult<PlaidItemUpdatedSubscription>
export const TransactionsByAccountDocument = gql`
  query TransactionsByAccount($id: ID!, $after: String, $before: String, $first: Int, $last: Int) {
    account(id: $id) {
      id
      lastFourDigits
      metadata
      name
      transactionsConnection(
        sort: DATE_DESC
        first: $first
        last: $last
        after: $after
        before: $before
      ) {
        pageInfo {
          endCursor
          hasNextPage
          hasPreviousPage
          startCursor
        }
        edges {
          cursor
          node {
            id
            description
            amount
            date
            entryType
            status
            sources {
              ... on SpadeTransaction {
                logo {
                  path
                  verified
                }
                normalizedMerchantName
              }
            }
          }
        }
        count
      }
    }
  }
`

/**
 * __useTransactionsByAccountQuery__
 *
 * To run a query within a React component, call `useTransactionsByAccountQuery` and pass it any options that fit your needs.
 * When your component renders, `useTransactionsByAccountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTransactionsByAccountQuery({
 *   variables: {
 *      id: // value for 'id'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useTransactionsByAccountQuery(
  baseOptions: Apollo.QueryHookOptions<
    TransactionsByAccountQuery,
    TransactionsByAccountQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<TransactionsByAccountQuery, TransactionsByAccountQueryVariables>(
    TransactionsByAccountDocument,
    options
  )
}
export function useTransactionsByAccountLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    TransactionsByAccountQuery,
    TransactionsByAccountQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<TransactionsByAccountQuery, TransactionsByAccountQueryVariables>(
    TransactionsByAccountDocument,
    options
  )
}
export type TransactionsByAccountQueryHookResult = ReturnType<typeof useTransactionsByAccountQuery>
export type TransactionsByAccountLazyQueryHookResult = ReturnType<
  typeof useTransactionsByAccountLazyQuery
>
export type TransactionsByAccountQueryResult = Apollo.QueryResult<
  TransactionsByAccountQuery,
  TransactionsByAccountQueryVariables
>
export const NextPaycheckQueryDocument = gql`
  query NextPaycheckQuery {
    profile {
      name
    }
  }
`

/**
 * __useNextPaycheckQueryQuery__
 *
 * To run a query within a React component, call `useNextPaycheckQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useNextPaycheckQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNextPaycheckQueryQuery({
 *   variables: {
 *   },
 * });
 */
export function useNextPaycheckQueryQuery(
  baseOptions?: Apollo.QueryHookOptions<NextPaycheckQueryQuery, NextPaycheckQueryQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<NextPaycheckQueryQuery, NextPaycheckQueryQueryVariables>(
    NextPaycheckQueryDocument,
    options
  )
}
export function useNextPaycheckQueryLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<NextPaycheckQueryQuery, NextPaycheckQueryQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<NextPaycheckQueryQuery, NextPaycheckQueryQueryVariables>(
    NextPaycheckQueryDocument,
    options
  )
}
export type NextPaycheckQueryQueryHookResult = ReturnType<typeof useNextPaycheckQueryQuery>
export type NextPaycheckQueryLazyQueryHookResult = ReturnType<typeof useNextPaycheckQueryLazyQuery>
export type NextPaycheckQueryQueryResult = Apollo.QueryResult<
  NextPaycheckQueryQuery,
  NextPaycheckQueryQueryVariables
>
export const RoundUpActivateDocument = gql`
  mutation RoundUpActivate($id: ID!, $startAt: DateTime!, $startOn: Date) {
    roundUpSetStartTime(input: { id: $id, startAt: $startAt }) {
      success
      record {
        id
        balance(filter: { date_gte: $startOn }) {
          id
          available
        }
        transactionsConnection(filter: { date_gte: $startOn }) {
          nodes {
            id
            date
            amount
            description
          }
        }
      }
    }
  }
`
export type RoundUpActivateMutationFn = Apollo.MutationFunction<
  RoundUpActivateMutation,
  RoundUpActivateMutationVariables
>

/**
 * __useRoundUpActivateMutation__
 *
 * To run a mutation, you first call `useRoundUpActivateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpActivateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpActivateMutation, { data, loading, error }] = useRoundUpActivateMutation({
 *   variables: {
 *      id: // value for 'id'
 *      startAt: // value for 'startAt'
 *      startOn: // value for 'startOn'
 *   },
 * });
 */
export function useRoundUpActivateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpActivateMutation,
    RoundUpActivateMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<RoundUpActivateMutation, RoundUpActivateMutationVariables>(
    RoundUpActivateDocument,
    options
  )
}
export type RoundUpActivateMutationHookResult = ReturnType<typeof useRoundUpActivateMutation>
export type RoundUpActivateMutationResult = Apollo.MutationResult<RoundUpActivateMutation>
export type RoundUpActivateMutationOptions = Apollo.BaseMutationOptions<
  RoundUpActivateMutation,
  RoundUpActivateMutationVariables
>
export const RoundUpActivateDateSearchDocument = gql`
  query RoundUpActivateDateSearch($id: ID!) {
    roundUp(id: $id) {
      id
      subscribedAccounts {
        id
        transactions(limit: 15, filter: { amount_lt: 0 }) {
          id
          date
          amount
          status
        }
      }
    }
  }
`

/**
 * __useRoundUpActivateDateSearchQuery__
 *
 * To run a query within a React component, call `useRoundUpActivateDateSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpActivateDateSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpActivateDateSearchQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpActivateDateSearchQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpActivateDateSearchQuery,
    RoundUpActivateDateSearchQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpActivateDateSearchQuery, RoundUpActivateDateSearchQueryVariables>(
    RoundUpActivateDateSearchDocument,
    options
  )
}
export function useRoundUpActivateDateSearchLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpActivateDateSearchQuery,
    RoundUpActivateDateSearchQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpActivateDateSearchQuery,
    RoundUpActivateDateSearchQueryVariables
  >(RoundUpActivateDateSearchDocument, options)
}
export type RoundUpActivateDateSearchQueryHookResult = ReturnType<
  typeof useRoundUpActivateDateSearchQuery
>
export type RoundUpActivateDateSearchLazyQueryHookResult = ReturnType<
  typeof useRoundUpActivateDateSearchLazyQuery
>
export type RoundUpActivateDateSearchQueryResult = Apollo.QueryResult<
  RoundUpActivateDateSearchQuery,
  RoundUpActivateDateSearchQueryVariables
>
export const RoundUpsBankConnectionsAccountsListDocument = gql`
  query RoundUpsBankConnectionsAccountsList($roundUpId: ID!, $bankConnectionId: ID!) {
    roundUp(id: $roundUpId) {
      id
      fundingAccount {
        id
        balance {
          current
        }
      }
    }
    plaidItem(id: $bankConnectionId) {
      id
      name
      logo {
        url
      }
      accounts {
        id
        name
      }
      status
      syncedAt
    }
  }
`

/**
 * __useRoundUpsBankConnectionsAccountsListQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsAccountsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsAccountsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsAccountsListQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      bankConnectionId: // value for 'bankConnectionId'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsAccountsListQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsAccountsListQuery,
    RoundUpsBankConnectionsAccountsListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsAccountsListQuery,
    RoundUpsBankConnectionsAccountsListQueryVariables
  >(RoundUpsBankConnectionsAccountsListDocument, options)
}
export function useRoundUpsBankConnectionsAccountsListLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsAccountsListQuery,
    RoundUpsBankConnectionsAccountsListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsAccountsListQuery,
    RoundUpsBankConnectionsAccountsListQueryVariables
  >(RoundUpsBankConnectionsAccountsListDocument, options)
}
export type RoundUpsBankConnectionsAccountsListQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAccountsListQuery
>
export type RoundUpsBankConnectionsAccountsListLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAccountsListLazyQuery
>
export type RoundUpsBankConnectionsAccountsListQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsAccountsListQuery,
  RoundUpsBankConnectionsAccountsListQueryVariables
>
export const RoundUpsBankConnectionsAccountsListItemDocument = gql`
  query RoundUpsBankConnectionsAccountsListItem($roundUpId: ID!, $accountId: ID!) {
    roundUp(id: $roundUpId) {
      id
      fundingAccount {
        id
        balance {
          current
        }
      }
      subscribedAccounts {
        id
      }
      availableAccounts {
        id
      }
    }
    account(id: $accountId) {
      id
      name
      lastFourDigits
      balance {
        current
      }
    }
  }
`

/**
 * __useRoundUpsBankConnectionsAccountsListItemQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsAccountsListItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsAccountsListItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsAccountsListItemQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsAccountsListItemQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsAccountsListItemQuery,
    RoundUpsBankConnectionsAccountsListItemQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsAccountsListItemQuery,
    RoundUpsBankConnectionsAccountsListItemQueryVariables
  >(RoundUpsBankConnectionsAccountsListItemDocument, options)
}
export function useRoundUpsBankConnectionsAccountsListItemLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsAccountsListItemQuery,
    RoundUpsBankConnectionsAccountsListItemQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsAccountsListItemQuery,
    RoundUpsBankConnectionsAccountsListItemQueryVariables
  >(RoundUpsBankConnectionsAccountsListItemDocument, options)
}
export type RoundUpsBankConnectionsAccountsListItemQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAccountsListItemQuery
>
export type RoundUpsBankConnectionsAccountsListItemLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAccountsListItemLazyQuery
>
export type RoundUpsBankConnectionsAccountsListItemQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsAccountsListItemQuery,
  RoundUpsBankConnectionsAccountsListItemQueryVariables
>
export const RoundUpsAccountsSubscribeDocument = gql`
  mutation RoundUpsAccountsSubscribe($id: ID!, $accountId: ID!) {
    roundUpSubscribedAccountsAdd(input: { id: $id, accountIds: [$accountId] }) {
      record {
        id
        subscribedAccounts {
          id
        }
        availableAccounts {
          id
        }
      }
    }
  }
`
export type RoundUpsAccountsSubscribeMutationFn = Apollo.MutationFunction<
  RoundUpsAccountsSubscribeMutation,
  RoundUpsAccountsSubscribeMutationVariables
>

/**
 * __useRoundUpsAccountsSubscribeMutation__
 *
 * To run a mutation, you first call `useRoundUpsAccountsSubscribeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsAccountsSubscribeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsAccountsSubscribeMutation, { data, loading, error }] = useRoundUpsAccountsSubscribeMutation({
 *   variables: {
 *      id: // value for 'id'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useRoundUpsAccountsSubscribeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsAccountsSubscribeMutation,
    RoundUpsAccountsSubscribeMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    RoundUpsAccountsSubscribeMutation,
    RoundUpsAccountsSubscribeMutationVariables
  >(RoundUpsAccountsSubscribeDocument, options)
}
export type RoundUpsAccountsSubscribeMutationHookResult = ReturnType<
  typeof useRoundUpsAccountsSubscribeMutation
>
export type RoundUpsAccountsSubscribeMutationResult =
  Apollo.MutationResult<RoundUpsAccountsSubscribeMutation>
export type RoundUpsAccountsSubscribeMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsAccountsSubscribeMutation,
  RoundUpsAccountsSubscribeMutationVariables
>
export const RoundUpsAccountsUnsubscribeDocument = gql`
  mutation RoundUpsAccountsUnsubscribe($id: ID!, $accountId: ID!) {
    roundUpSubscribedAccountsRemove(input: { id: $id, accountIds: [$accountId] }) {
      record {
        id
        subscribedAccounts {
          id
        }
        availableAccounts {
          id
        }
      }
    }
  }
`
export type RoundUpsAccountsUnsubscribeMutationFn = Apollo.MutationFunction<
  RoundUpsAccountsUnsubscribeMutation,
  RoundUpsAccountsUnsubscribeMutationVariables
>

/**
 * __useRoundUpsAccountsUnsubscribeMutation__
 *
 * To run a mutation, you first call `useRoundUpsAccountsUnsubscribeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsAccountsUnsubscribeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsAccountsUnsubscribeMutation, { data, loading, error }] = useRoundUpsAccountsUnsubscribeMutation({
 *   variables: {
 *      id: // value for 'id'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useRoundUpsAccountsUnsubscribeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsAccountsUnsubscribeMutation,
    RoundUpsAccountsUnsubscribeMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    RoundUpsAccountsUnsubscribeMutation,
    RoundUpsAccountsUnsubscribeMutationVariables
  >(RoundUpsAccountsUnsubscribeDocument, options)
}
export type RoundUpsAccountsUnsubscribeMutationHookResult = ReturnType<
  typeof useRoundUpsAccountsUnsubscribeMutation
>
export type RoundUpsAccountsUnsubscribeMutationResult =
  Apollo.MutationResult<RoundUpsAccountsUnsubscribeMutation>
export type RoundUpsAccountsUnsubscribeMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsAccountsUnsubscribeMutation,
  RoundUpsAccountsUnsubscribeMutationVariables
>
export const RoundUpsBankConnectionsAddFundingDocument = gql`
  mutation RoundUpsBankConnectionsAddFunding($roundUpId: ID!, $accountId: ID!) {
    roundUpSetFundingAccount(input: { id: $roundUpId, accountId: $accountId }) {
      success
      record {
        id
      }
    }
    roundUpSubscribedAccountsAdd(input: { id: $roundUpId, accountIds: [$accountId] }) {
      success
      record {
        id
      }
    }
  }
`
export type RoundUpsBankConnectionsAddFundingMutationFn = Apollo.MutationFunction<
  RoundUpsBankConnectionsAddFundingMutation,
  RoundUpsBankConnectionsAddFundingMutationVariables
>

/**
 * __useRoundUpsBankConnectionsAddFundingMutation__
 *
 * To run a mutation, you first call `useRoundUpsBankConnectionsAddFundingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsAddFundingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsBankConnectionsAddFundingMutation, { data, loading, error }] = useRoundUpsBankConnectionsAddFundingMutation({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsAddFundingMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsBankConnectionsAddFundingMutation,
    RoundUpsBankConnectionsAddFundingMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    RoundUpsBankConnectionsAddFundingMutation,
    RoundUpsBankConnectionsAddFundingMutationVariables
  >(RoundUpsBankConnectionsAddFundingDocument, options)
}
export type RoundUpsBankConnectionsAddFundingMutationHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAddFundingMutation
>
export type RoundUpsBankConnectionsAddFundingMutationResult =
  Apollo.MutationResult<RoundUpsBankConnectionsAddFundingMutation>
export type RoundUpsBankConnectionsAddFundingMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsBankConnectionsAddFundingMutation,
  RoundUpsBankConnectionsAddFundingMutationVariables
>
export const RoundUpsBankConnectionsAddSubscriptionDocument = gql`
  mutation RoundUpsBankConnectionsAddSubscription($roundUpId: ID!, $accountIds: [ID!]!) {
    roundUpSubscribedAccountsAdd(input: { id: $roundUpId, accountIds: $accountIds }) {
      success
      record {
        id
      }
    }
  }
`
export type RoundUpsBankConnectionsAddSubscriptionMutationFn = Apollo.MutationFunction<
  RoundUpsBankConnectionsAddSubscriptionMutation,
  RoundUpsBankConnectionsAddSubscriptionMutationVariables
>

/**
 * __useRoundUpsBankConnectionsAddSubscriptionMutation__
 *
 * To run a mutation, you first call `useRoundUpsBankConnectionsAddSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsAddSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsBankConnectionsAddSubscriptionMutation, { data, loading, error }] = useRoundUpsBankConnectionsAddSubscriptionMutation({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      accountIds: // value for 'accountIds'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsAddSubscriptionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsBankConnectionsAddSubscriptionMutation,
    RoundUpsBankConnectionsAddSubscriptionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    RoundUpsBankConnectionsAddSubscriptionMutation,
    RoundUpsBankConnectionsAddSubscriptionMutationVariables
  >(RoundUpsBankConnectionsAddSubscriptionDocument, options)
}
export type RoundUpsBankConnectionsAddSubscriptionMutationHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAddSubscriptionMutation
>
export type RoundUpsBankConnectionsAddSubscriptionMutationResult =
  Apollo.MutationResult<RoundUpsBankConnectionsAddSubscriptionMutation>
export type RoundUpsBankConnectionsAddSubscriptionMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsBankConnectionsAddSubscriptionMutation,
  RoundUpsBankConnectionsAddSubscriptionMutationVariables
>
export const RoundUpsRecentActivityDocument = gql`
  query RoundUpsRecentActivity($roundUpId: ID!, $since: Date!) {
    roundUp(id: $roundUpId) {
      id
      recentActivity: balance(filter: { date_gte: $since }) {
        id
        current
      }
    }
  }
`

/**
 * __useRoundUpsRecentActivityQuery__
 *
 * To run a query within a React component, call `useRoundUpsRecentActivityQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsRecentActivityQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsRecentActivityQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      since: // value for 'since'
 *   },
 * });
 */
export function useRoundUpsRecentActivityQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsRecentActivityQuery,
    RoundUpsRecentActivityQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpsRecentActivityQuery, RoundUpsRecentActivityQueryVariables>(
    RoundUpsRecentActivityDocument,
    options
  )
}
export function useRoundUpsRecentActivityLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsRecentActivityQuery,
    RoundUpsRecentActivityQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<RoundUpsRecentActivityQuery, RoundUpsRecentActivityQueryVariables>(
    RoundUpsRecentActivityDocument,
    options
  )
}
export type RoundUpsRecentActivityQueryHookResult = ReturnType<
  typeof useRoundUpsRecentActivityQuery
>
export type RoundUpsRecentActivityLazyQueryHookResult = ReturnType<
  typeof useRoundUpsRecentActivityLazyQuery
>
export type RoundUpsRecentActivityQueryResult = Apollo.QueryResult<
  RoundUpsRecentActivityQuery,
  RoundUpsRecentActivityQueryVariables
>
export const RoundUpsBankConnectionsSummaryCardFooterDocument = gql`
  query RoundUpsBankConnectionsSummaryCardFooter($id: ID!) {
    roundUp(id: $id) {
      id
      fundingAccount {
        id
        balance {
          current
        }
      }
    }
  }
`

/**
 * __useRoundUpsBankConnectionsSummaryCardFooterQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsSummaryCardFooterQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsSummaryCardFooterQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsSummaryCardFooterQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsSummaryCardFooterQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsSummaryCardFooterQuery,
    RoundUpsBankConnectionsSummaryCardFooterQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsSummaryCardFooterQuery,
    RoundUpsBankConnectionsSummaryCardFooterQueryVariables
  >(RoundUpsBankConnectionsSummaryCardFooterDocument, options)
}
export function useRoundUpsBankConnectionsSummaryCardFooterLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsSummaryCardFooterQuery,
    RoundUpsBankConnectionsSummaryCardFooterQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsSummaryCardFooterQuery,
    RoundUpsBankConnectionsSummaryCardFooterQueryVariables
  >(RoundUpsBankConnectionsSummaryCardFooterDocument, options)
}
export type RoundUpsBankConnectionsSummaryCardFooterQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsSummaryCardFooterQuery
>
export type RoundUpsBankConnectionsSummaryCardFooterLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsSummaryCardFooterLazyQuery
>
export type RoundUpsBankConnectionsSummaryCardFooterQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsSummaryCardFooterQuery,
  RoundUpsBankConnectionsSummaryCardFooterQueryVariables
>
export const RoundUpsBankConnectionsSummaryCardHeaderDocument = gql`
  query RoundUpsBankConnectionsSummaryCardHeader {
    plaidItems {
      id
    }
  }
`

/**
 * __useRoundUpsBankConnectionsSummaryCardHeaderQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsSummaryCardHeaderQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsSummaryCardHeaderQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsSummaryCardHeaderQuery({
 *   variables: {
 *   },
 * });
 */
export function useRoundUpsBankConnectionsSummaryCardHeaderQuery(
  baseOptions?: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsSummaryCardHeaderQuery,
    RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsSummaryCardHeaderQuery,
    RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
  >(RoundUpsBankConnectionsSummaryCardHeaderDocument, options)
}
export function useRoundUpsBankConnectionsSummaryCardHeaderLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsSummaryCardHeaderQuery,
    RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsSummaryCardHeaderQuery,
    RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
  >(RoundUpsBankConnectionsSummaryCardHeaderDocument, options)
}
export type RoundUpsBankConnectionsSummaryCardHeaderQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsSummaryCardHeaderQuery
>
export type RoundUpsBankConnectionsSummaryCardHeaderLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsSummaryCardHeaderLazyQuery
>
export type RoundUpsBankConnectionsSummaryCardHeaderQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsSummaryCardHeaderQuery,
  RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
>
export const RoundUpsBankConnectionsCardDocument = gql`
  query RoundUpsBankConnectionsCard($roundUpId: ID!, $id: ID!) {
    roundUp(id: $roundUpId) {
      id
    }
    plaidItem(id: $id) {
      id
      name
      logo {
        url
      }
      status
      syncedAt
    }
  }
`

/**
 * __useRoundUpsBankConnectionsCardQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsCardQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsCardQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsCardQuery,
    RoundUpsBankConnectionsCardQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsCardQuery,
    RoundUpsBankConnectionsCardQueryVariables
  >(RoundUpsBankConnectionsCardDocument, options)
}
export function useRoundUpsBankConnectionsCardLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsCardQuery,
    RoundUpsBankConnectionsCardQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsCardQuery,
    RoundUpsBankConnectionsCardQueryVariables
  >(RoundUpsBankConnectionsCardDocument, options)
}
export type RoundUpsBankConnectionsCardQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsCardQuery
>
export type RoundUpsBankConnectionsCardLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsCardLazyQuery
>
export type RoundUpsBankConnectionsCardQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsCardQuery,
  RoundUpsBankConnectionsCardQueryVariables
>
export const RoundUpsBankConnectionsListDocument = gql`
  query RoundUpsBankConnectionsList($roundUpId: ID!) {
    roundUp(id: $roundUpId) {
      id
      fundingAccount {
        ...AccountAttributes
        balance {
          current
        }
      }
    }
    plaidItems {
      id
      name
      logo {
        url
      }
      status
      syncedAt
    }
  }
  ${AccountAttributesFragmentDoc}
`

/**
 * __useRoundUpsBankConnectionsListQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsListQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsListQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsListQuery,
    RoundUpsBankConnectionsListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsListQuery,
    RoundUpsBankConnectionsListQueryVariables
  >(RoundUpsBankConnectionsListDocument, options)
}
export function useRoundUpsBankConnectionsListLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsListQuery,
    RoundUpsBankConnectionsListQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsListQuery,
    RoundUpsBankConnectionsListQueryVariables
  >(RoundUpsBankConnectionsListDocument, options)
}
export type RoundUpsBankConnectionsListQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsListQuery
>
export type RoundUpsBankConnectionsListLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsListLazyQuery
>
export type RoundUpsBankConnectionsListQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsListQuery,
  RoundUpsBankConnectionsListQueryVariables
>
export const RoundUpsBankConnectionsListItemDocument = gql`
  query RoundUpsBankConnectionsListItem($roundUpId: ID!, $id: ID!) {
    roundUp(id: $roundUpId) {
      id
      fundingAccount {
        ...AccountAttributes
        balance {
          current
        }
      }
    }
    plaidItem(id: $id) {
      id
      name
      logo {
        url
      }
      status
      syncedAt
    }
  }
  ${AccountAttributesFragmentDoc}
`

/**
 * __useRoundUpsBankConnectionsListItemQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsListItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsListItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsListItemQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsListItemQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsListItemQuery,
    RoundUpsBankConnectionsListItemQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsListItemQuery,
    RoundUpsBankConnectionsListItemQueryVariables
  >(RoundUpsBankConnectionsListItemDocument, options)
}
export function useRoundUpsBankConnectionsListItemLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsListItemQuery,
    RoundUpsBankConnectionsListItemQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsListItemQuery,
    RoundUpsBankConnectionsListItemQueryVariables
  >(RoundUpsBankConnectionsListItemDocument, options)
}
export type RoundUpsBankConnectionsListItemQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsListItemQuery
>
export type RoundUpsBankConnectionsListItemLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsListItemLazyQuery
>
export type RoundUpsBankConnectionsListItemQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsListItemQuery,
  RoundUpsBankConnectionsListItemQueryVariables
>
export const RoundUpsBankConnectionsPageDocument = gql`
  query RoundUpsBankConnectionsPage($id: ID!) {
    roundUp(id: $id) {
      id
      fundingAccount {
        id
        balance {
          current
        }
      }
    }
    plaidItems {
      id
      accounts {
        id
      }
    }
  }
`

/**
 * __useRoundUpsBankConnectionsPageQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsPageQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsPageQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsPageQuery,
    RoundUpsBankConnectionsPageQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    RoundUpsBankConnectionsPageQuery,
    RoundUpsBankConnectionsPageQueryVariables
  >(RoundUpsBankConnectionsPageDocument, options)
}
export function useRoundUpsBankConnectionsPageLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsPageQuery,
    RoundUpsBankConnectionsPageQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsPageQuery,
    RoundUpsBankConnectionsPageQueryVariables
  >(RoundUpsBankConnectionsPageDocument, options)
}
export type RoundUpsBankConnectionsPageQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsPageQuery
>
export type RoundUpsBankConnectionsPageLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsPageLazyQuery
>
export type RoundUpsBankConnectionsPageQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsPageQuery,
  RoundUpsBankConnectionsPageQueryVariables
>
export const RoundUpsPauseDocument = gql`
  mutation RoundUpsPause($id: ID!) {
    roundUpPause(input: { id: $id }) {
      record {
        id
        status
      }
    }
  }
`
export type RoundUpsPauseMutationFn = Apollo.MutationFunction<
  RoundUpsPauseMutation,
  RoundUpsPauseMutationVariables
>

/**
 * __useRoundUpsPauseMutation__
 *
 * To run a mutation, you first call `useRoundUpsPauseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsPauseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsPauseMutation, { data, loading, error }] = useRoundUpsPauseMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsPauseMutation(
  baseOptions?: Apollo.MutationHookOptions<RoundUpsPauseMutation, RoundUpsPauseMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<RoundUpsPauseMutation, RoundUpsPauseMutationVariables>(
    RoundUpsPauseDocument,
    options
  )
}
export type RoundUpsPauseMutationHookResult = ReturnType<typeof useRoundUpsPauseMutation>
export type RoundUpsPauseMutationResult = Apollo.MutationResult<RoundUpsPauseMutation>
export type RoundUpsPauseMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsPauseMutation,
  RoundUpsPauseMutationVariables
>
export const RoundUpsResumeDocument = gql`
  mutation RoundUpsResume($id: ID!) {
    roundUpResume(input: { id: $id }) {
      record {
        id
        status
      }
    }
  }
`
export type RoundUpsResumeMutationFn = Apollo.MutationFunction<
  RoundUpsResumeMutation,
  RoundUpsResumeMutationVariables
>

/**
 * __useRoundUpsResumeMutation__
 *
 * To run a mutation, you first call `useRoundUpsResumeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsResumeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsResumeMutation, { data, loading, error }] = useRoundUpsResumeMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsResumeMutation(
  baseOptions?: Apollo.MutationHookOptions<RoundUpsResumeMutation, RoundUpsResumeMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<RoundUpsResumeMutation, RoundUpsResumeMutationVariables>(
    RoundUpsResumeDocument,
    options
  )
}
export type RoundUpsResumeMutationHookResult = ReturnType<typeof useRoundUpsResumeMutation>
export type RoundUpsResumeMutationResult = Apollo.MutationResult<RoundUpsResumeMutation>
export type RoundUpsResumeMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsResumeMutation,
  RoundUpsResumeMutationVariables
>
export const RoundUpSummaryDocument = gql`
  query RoundUpSummary($id: ID!, $startOfWeek: Date) {
    roundUp(id: $id) {
      id
      totalAmount: balance {
        id
        available
        current
      }
      thisWeek: balance(filter: { date_gte: $startOfWeek }) {
        id
        available
        current
      }
    }
  }
`

/**
 * __useRoundUpSummaryQuery__
 *
 * To run a query within a React component, call `useRoundUpSummaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpSummaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpSummaryQuery({
 *   variables: {
 *      id: // value for 'id'
 *      startOfWeek: // value for 'startOfWeek'
 *   },
 * });
 */
export function useRoundUpSummaryQuery(
  baseOptions: Apollo.QueryHookOptions<RoundUpSummaryQuery, RoundUpSummaryQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpSummaryQuery, RoundUpSummaryQueryVariables>(
    RoundUpSummaryDocument,
    options
  )
}
export function useRoundUpSummaryLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<RoundUpSummaryQuery, RoundUpSummaryQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<RoundUpSummaryQuery, RoundUpSummaryQueryVariables>(
    RoundUpSummaryDocument,
    options
  )
}
export type RoundUpSummaryQueryHookResult = ReturnType<typeof useRoundUpSummaryQuery>
export type RoundUpSummaryLazyQueryHookResult = ReturnType<typeof useRoundUpSummaryLazyQuery>
export type RoundUpSummaryQueryResult = Apollo.QueryResult<
  RoundUpSummaryQuery,
  RoundUpSummaryQueryVariables
>
export const RoundUpHistoryDocument = gql`
  query RoundUpHistory(
    $id: ID!
    $day0: Date!
    $day1: Date!
    $day2: Date!
    $day3: Date!
    $day4: Date!
    $day5: Date!
    $day6: Date!
  ) {
    roundUp(id: $id) {
      id
      day0: balance(filter: { date_gte: $day0 }) {
        id
        available
      }
      day1: balance(filter: { date_lt: $day0, date_gte: $day1 }) {
        id
        available
      }
      day2: balance(filter: { date_lt: $day1, date_gte: $day2 }) {
        id
        available
      }
      day3: balance(filter: { date_lt: $day2, date_gte: $day3 }) {
        id
        available
      }
      day4: balance(filter: { date_lt: $day3, date_gte: $day4 }) {
        id
        available
      }
      day5: balance(filter: { date_lt: $day4, date_gte: $day5 }) {
        id
        available
      }
      day6: balance(filter: { date_lt: $day5, date_gte: $day6 }) {
        id
        available
      }
    }
  }
`

/**
 * __useRoundUpHistoryQuery__
 *
 * To run a query within a React component, call `useRoundUpHistoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpHistoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpHistoryQuery({
 *   variables: {
 *      id: // value for 'id'
 *      day0: // value for 'day0'
 *      day1: // value for 'day1'
 *      day2: // value for 'day2'
 *      day3: // value for 'day3'
 *      day4: // value for 'day4'
 *      day5: // value for 'day5'
 *      day6: // value for 'day6'
 *   },
 * });
 */
export function useRoundUpHistoryQuery(
  baseOptions: Apollo.QueryHookOptions<RoundUpHistoryQuery, RoundUpHistoryQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpHistoryQuery, RoundUpHistoryQueryVariables>(
    RoundUpHistoryDocument,
    options
  )
}
export function useRoundUpHistoryLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<RoundUpHistoryQuery, RoundUpHistoryQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<RoundUpHistoryQuery, RoundUpHistoryQueryVariables>(
    RoundUpHistoryDocument,
    options
  )
}
export type RoundUpHistoryQueryHookResult = ReturnType<typeof useRoundUpHistoryQuery>
export type RoundUpHistoryLazyQueryHookResult = ReturnType<typeof useRoundUpHistoryLazyQuery>
export type RoundUpHistoryQueryResult = Apollo.QueryResult<
  RoundUpHistoryQuery,
  RoundUpHistoryQueryVariables
>
export const RoundUpTransactionsDocument = gql`
  query RoundUpTransactions($id: ID!) {
    roundUp(id: $id) {
      id
      transactionsConnection {
        edges {
          node {
            id
            date
            amount
            description
          }
        }
      }
    }
  }
`

/**
 * __useRoundUpTransactionsQuery__
 *
 * To run a query within a React component, call `useRoundUpTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpTransactionsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpTransactionsQuery(
  baseOptions: Apollo.QueryHookOptions<RoundUpTransactionsQuery, RoundUpTransactionsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpTransactionsQuery, RoundUpTransactionsQueryVariables>(
    RoundUpTransactionsDocument,
    options
  )
}
export function useRoundUpTransactionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpTransactionsQuery,
    RoundUpTransactionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<RoundUpTransactionsQuery, RoundUpTransactionsQueryVariables>(
    RoundUpTransactionsDocument,
    options
  )
}
export type RoundUpTransactionsQueryHookResult = ReturnType<typeof useRoundUpTransactionsQuery>
export type RoundUpTransactionsLazyQueryHookResult = ReturnType<
  typeof useRoundUpTransactionsLazyQuery
>
export type RoundUpTransactionsQueryResult = Apollo.QueryResult<
  RoundUpTransactionsQuery,
  RoundUpTransactionsQueryVariables
>
export const RoundUpsDocument = gql`
  query RoundUps {
    roundUps {
      id
    }
  }
`

/**
 * __useRoundUpsQuery__
 *
 * To run a query within a React component, call `useRoundUpsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsQuery({
 *   variables: {
 *   },
 * });
 */
export function useRoundUpsQuery(
  baseOptions?: Apollo.QueryHookOptions<RoundUpsQuery, RoundUpsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpsQuery, RoundUpsQueryVariables>(RoundUpsDocument, options)
}
export function useRoundUpsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<RoundUpsQuery, RoundUpsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<RoundUpsQuery, RoundUpsQueryVariables>(RoundUpsDocument, options)
}
export type RoundUpsQueryHookResult = ReturnType<typeof useRoundUpsQuery>
export type RoundUpsLazyQueryHookResult = ReturnType<typeof useRoundUpsLazyQuery>
export type RoundUpsQueryResult = Apollo.QueryResult<RoundUpsQuery, RoundUpsQueryVariables>
export const RoundUpHomeDocument = gql`
  query RoundUpHome($id: ID!) {
    roundUp(id: $id) {
      id
      status
      fundingAccount {
        id
        balance {
          current
        }
      }
    }
  }
`

/**
 * __useRoundUpHomeQuery__
 *
 * To run a query within a React component, call `useRoundUpHomeQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpHomeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpHomeQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpHomeQuery(
  baseOptions: Apollo.QueryHookOptions<RoundUpHomeQuery, RoundUpHomeQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RoundUpHomeQuery, RoundUpHomeQueryVariables>(RoundUpHomeDocument, options)
}
export function useRoundUpHomeLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<RoundUpHomeQuery, RoundUpHomeQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<RoundUpHomeQuery, RoundUpHomeQueryVariables>(
    RoundUpHomeDocument,
    options
  )
}
export type RoundUpHomeQueryHookResult = ReturnType<typeof useRoundUpHomeQuery>
export type RoundUpHomeLazyQueryHookResult = ReturnType<typeof useRoundUpHomeLazyQuery>
export type RoundUpHomeQueryResult = Apollo.QueryResult<RoundUpHomeQuery, RoundUpHomeQueryVariables>
export const CreateRoundUpDocument = gql`
  mutation CreateRoundUp($input: RoundUpCreateInput!) {
    roundUpCreate(input: $input) {
      success
      record {
        id
        status
      }
    }
  }
`
export type CreateRoundUpMutationFn = Apollo.MutationFunction<
  CreateRoundUpMutation,
  CreateRoundUpMutationVariables
>

/**
 * __useCreateRoundUpMutation__
 *
 * To run a mutation, you first call `useCreateRoundUpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRoundUpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRoundUpMutation, { data, loading, error }] = useCreateRoundUpMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateRoundUpMutation(
  baseOptions?: Apollo.MutationHookOptions<CreateRoundUpMutation, CreateRoundUpMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<CreateRoundUpMutation, CreateRoundUpMutationVariables>(
    CreateRoundUpDocument,
    options
  )
}
export type CreateRoundUpMutationHookResult = ReturnType<typeof useCreateRoundUpMutation>
export type CreateRoundUpMutationResult = Apollo.MutationResult<CreateRoundUpMutation>
export type CreateRoundUpMutationOptions = Apollo.BaseMutationOptions<
  CreateRoundUpMutation,
  CreateRoundUpMutationVariables
>
